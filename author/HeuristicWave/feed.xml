<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator>
  <link href="https://heuristicwave.github.io/author/HeuristicWave/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://heuristicwave.github.io/" rel="alternate" type="text/html" />
  <updated>2023-01-26T03:12:38+00:00</updated>
  <id>https://heuristicwave.github.io/author/HeuristicWave/feed.xml</id>

  
  
  

  
    <title type="html">Heuristic Wave Blog | </title>
  

  
    <subtitle>Careful Writer</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">DIY Amazon EKS with eksctl</title>
      <link href="https://heuristicwave.github.io/eksctl_ppt" rel="alternate" type="text/html" title="DIY Amazon EKS with eksctl" />
      <published>2023-01-19T19:00:00+00:00</published>
      <updated>2023-01-19T19:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/eksctl_ppt</id>
      <content type="html" xml:base="https://heuristicwave.github.io/eksctl_ppt">&lt;p&gt;&lt;a href=&quot;https://www.meetup.com/awskrug/events/290666942/&quot;&gt;AWSKRUG 컨테이너 소모임🐳 - 1월 19일(목)&lt;/a&gt; 발표 자료&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;eksctl을 현업에서 적용하기 위해 필수적으로 필요한 최소한의 요소들을 다룹니다.&lt;/p&gt;

&lt;iframe src=&quot;https://www.slideshare.net/slideshow/embed_code/key/KnHQ8gpSIFKpbE?hostedIn=slideshare&amp;amp;page=upload&quot; width=&quot;840&quot; height=&quot;523&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;💡 SlideShare 링크를 통해 다운로드 받을 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;AWSKRUG에서는 첫 발표였는데, 부족한 발표임에도 19일 당일 소중한 시간을 내주셔서 감사합니다. 
추후, 해당 장표들을 설명하는 블로그 포스팅을 함께 개제할 예정입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;EKSCTL Tips&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./eksctl_ppt&quot;&gt;DIY Amazon EKS with eksctl (Deck)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="devops" />
      
        <category term="eks" />
      
        <category term="aws" />
      

      
        <summary type="html">AWSKRUG 컨테이너 소모임🐳 - 1월 19일(목) 발표 자료</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Goroutines</title>
      <link href="https://heuristicwave.github.io/Goroutines" rel="alternate" type="text/html" title="Goroutines" />
      <published>2022-10-16T00:00:00+00:00</published>
      <updated>2022-10-16T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/Goroutines</id>
      <content type="html" xml:base="https://heuristicwave.github.io/Goroutines">&lt;p&gt;Goroutines, Concurrent Programming in Go&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;해당 포스팅은 &lt;a href=&quot;http://www.yes24.com/Product/Goods/99108736&quot;&gt;Tucker의 Go 언어 프로그래밍&lt;/a&gt; 24장 고루틴과 동시성 프로그래밍 읽고 정리한 내용임을 알립니다.
미루고 미루던 Go 언어 학습을, &lt;a href=&quot;https://heuristicwave.github.io/geultto2&quot;&gt;글또&lt;/a&gt; 덕분에 올해 Go 언어 학습을 끝마칠 수 있을 것 같습니다. 😵‍💫&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;goroutines&quot;&gt;Goroutines&lt;/h2&gt;

&lt;p&gt;고루틴은 Go 언어에서 관리하는 경량 스레드입니다. 함수나 명령을 동시에 수행할 때 사용하며, 여러 고루틴을 갖는 프로그램 코딩을 &lt;strong&gt;동시성 프로그래밍&lt;/strong&gt;이라고 합니다.
고루틴을 이해하기 위해, 선수 지식들을 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;thread&quot;&gt;Thread&lt;/h3&gt;

&lt;p&gt;메모리 공간에 로딩되어 동작하는 프로그램을 프로세스라고 합니다. 프로세스는 1개 이상의 작업 단위를 가지고 있으며, 이 작업 단위를 스레드라고 합니다.
스레드가 하나면 싱글 스레드 프로세스, 여럿이면 멀티 스레드 프로세스라 합니다.&lt;/p&gt;

&lt;p&gt;원래 CPU 코어는 한 번에 한 명령밖에 수행할 수 없습니다. 그러나 스레드가 CPU 코어를 빠르게 교대로 점유하면 동시에 모든 스레드가 실행되는 것처럼 보입니다.&lt;/p&gt;

&lt;h3 id=&quot;context-switching&quot;&gt;Context switching&lt;/h3&gt;

&lt;p&gt;CPU 코어가 여러 스레드를 전환하는 것을 &lt;strong&gt;컨텍스트 스위칭&lt;/strong&gt;이라고 합니다. 스레드를 전환하려면 현재 상태를 보관해야 다시 스레드가 전환되어 돌아올 때 마지막 실행 상태부터 이어서 실행이 가능합니다.
이를 위해 스레드의 명령 포인터(instruction pointer), 스택 메모리 등의 정보를 저장하는 데 이것을 &lt;strong&gt;스레드 컨텍스트&lt;/strong&gt;라고 합니다.&lt;/p&gt;

&lt;p&gt;스레드가 전환될 때마다 스레드 컨텍스트를 저장하고 복원하기 때문에 전환 비용이 발생하고 적정 개수를 넘어 너무 많은 스레드를 수행하면 성능이 저하됩니다.
하지만 &lt;strong&gt;Go 언어에서는 CPU 코어마다 OS 스레드를 하나만 할당해 사용하므로 컨텍스트 스위칭 비용이 발생하지 않습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;goroutines-example&quot;&gt;Goroutines Example&lt;/h2&gt;

&lt;p&gt;모든 프로그램은 최소 하나의 고루틴을 가지고 있습니다. 이는 메인 루틴으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; 함수와 함께 고루틴이 시작되고 종료됩니다.
이미 하나의 고루틴이 있으며, 추가로 고루틴을 생성하는 방법은 다음과 같이, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;go functionName()&lt;/code&gt; go 키워드와 함께 함수를 호출하는 것입니다.&lt;/p&gt;

&lt;p&gt;아래 코드는 2개의 서브 고루틴을 사용한 예시입니다. 어떤 결과가 나올지 예상해 보고, 하단의 결과를 열어 확인해 보세요 😎&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;time&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrintHangul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;hanguls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;rune&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'가'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'나'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'다'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'라'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'마'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'바'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'사'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hanguls&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;300&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Millisecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrintNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;400&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Millisecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrintNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrintHangul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;details&gt;
  &lt;summary&gt;👀 실행 결과 보기&lt;/summary&gt;

  &lt;p&gt;해당 코드는 고루틴이 생성되어 있지만, 메인 함수가 먼저 종료되어 아무런 결과도 출력되지 않습니다.
결과를 출력하기 위해서는 서브 고루틴이 모두 실행되고 완료되는 2000ms 보다 많은 시간을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; 함수에 넣으면 됩니다.&lt;/p&gt;

  &lt;p&gt;이렇게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;time.Sleep(3 * time.Second)&lt;/code&gt; 3000ms를 보장하는 코드를 삽입하면 모든 실행을 보장합니다.&lt;/p&gt;

&lt;/details&gt;

&lt;h3 id=&quot;실행-시간-보장하기&quot;&gt;실행 시간 보장하기&lt;/h3&gt;

&lt;p&gt;생성한 서브 고루틴들의 실행을 보장하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WaitGroup&lt;/code&gt; 객체를 사용하면 됩니다.&lt;/p&gt;
&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// 작업 개수 설정&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// 작업이 완료될 때마다 호출&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// 모든 작업이 완료될 때까지 대기&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 방법을 통해 위에 예시로 소개한 고루틴을 다음과 같이 수정하면 모든 실행을 보장할 수 있습니다.&lt;/p&gt;

&lt;details&gt;
  &lt;summary&gt;👀 서브 고루틴 기다리기&lt;/summary&gt;

  &lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;sync&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;time&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrintHangul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;hanguls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;rune&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'가'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'나'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'다'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'라'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'마'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'바'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'사'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hanguls&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;300&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Millisecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrintNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;400&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Millisecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrintNumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrintHangul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;c&quot;&gt;// time.Sleep(3 * time.Second)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

&lt;/details&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mechanism&quot;&gt;Mechanism&lt;/h2&gt;

&lt;p&gt;고루틴은 명령을 수행하는 단일 흐름으로 &lt;strong&gt;OS 스레드&lt;/strong&gt;를 이용하는 &lt;strong&gt;경량 스레드&lt;/strong&gt;입니다. 해당 정의를 이해하기 위해 OS 스레드와 고루틴이 어떻게 다른지 알아보겠습니다.
2개의 코어에서 2개의 고루틴이 존재한다 가정하면, 아래 그림과 같이 각 코어 별, OS 스레드에 하나의 고루틴이 실행됩니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ________           ______________         .&lt;span class=&quot;s1&quot;&gt;''''''''&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
|        |         /             /        /    Go    &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
| CORE 1 |--------/ OS Thread 1 /---------&lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;routine1 /
|________|       /_____________/           &lt;span class=&quot;s1&quot;&gt;'........'&lt;/span&gt;
 ________           ______________         .&lt;span class=&quot;s1&quot;&gt;''''''''&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
|        |         /             /        /    Go    &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
| CORE 2 |--------/ OS Thread 2 /---------&lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;routine2 /
|________|       /_____________/           &lt;span class=&quot;s1&quot;&gt;'........'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 상황에서 고루틴을 하나 더 생성하면, 남는 코어가 없으므로 3번째 고루틴은 다른 고루틴이 실행 완료될 때까지 대기 상태로 멈춰 있습니다.
만약 고루틴 2가 실행 완료되면, 그제야 대기하던 고루틴 3이 실행됩니다.&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ________           ______________         .&lt;span class=&quot;s1&quot;&gt;''''''''&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
|        |         /             /        /    Go    &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
| CORE 1 |--------/ OS Thread 1 /---------&lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;routine1 /
|________|       /_____________/           &lt;span class=&quot;s1&quot;&gt;'........'&lt;/span&gt;
 ________           ______________         .&lt;span class=&quot;s1&quot;&gt;''''''''&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
|        |         /             /        /    Go    &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
| CORE 2 |--------/ OS Thread 2 /---------&lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;routine2 /
|________|       /_____________/           &lt;span class=&quot;s1&quot;&gt;'........'&lt;/span&gt;
                                                ^
 .&lt;span class=&quot;s1&quot;&gt;'!Wait!'&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;                                     |
/    Go    &lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;_____After Goroutin 2 is removed___|
&lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;routine3 /
 &lt;span class=&quot;s1&quot;&gt;'.!Wait!.'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;system-call&quot;&gt;System Call&lt;/h3&gt;

&lt;p&gt;커널 서비스를 사용하기 위해 &lt;strong&gt;시스템 콜&lt;/strong&gt;을 호출하면, 해당 서비스가 완료될 때까지 대기 상태가 됩니다.
앞선 예시에서는 실행 중인 고루틴이 완료되기까지 대기 상태를 유지했다면, 시스템 콜이 발생한 상황(고루틴 3)에서는 해당 고루틴을 대기열로 보내고
대기하던 다른 고루틴(고루틴 4)을 실행하며 &lt;strong&gt;코어와 스레드 변경 없이&lt;/strong&gt; 고루틴만을 이동시킵니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ________           ______________         .&lt;span class=&quot;s1&quot;&gt;''''''''&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
|        |         /             /        /    Go    &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
| CORE 1 |--------/ OS Thread 1 /---------&lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;routine1 /
|________|       /_____________/           &lt;span class=&quot;s1&quot;&gt;'........'&lt;/span&gt;
 ________           ______________         .&lt;span class=&quot;s1&quot;&gt;''''''''&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
|        |         /             /        /    Go    &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
| CORE 2 |--------/ OS Thread 2 /---------&lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;routine3 /
|________|       /_____________/           &lt;span class=&quot;s1&quot;&gt;'........'&lt;/span&gt;
                                                ^
 .&lt;span class=&quot;s1&quot;&gt;'!Wait!'&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;                                     |
/    Go    &lt;span class=&quot;se&quot;&gt;\&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;------&lt;/span&gt; Switch only Goroutin &lt;span class=&quot;nt&quot;&gt;-------&lt;/span&gt;|
&lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;routine4 /  without changing cores and threads
 &lt;span class=&quot;s1&quot;&gt;'.!Wait!.'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이와 같이 고루틴을 이용하면 컨텍스트 스위칭과 없이 오직 고루틴만 옮겨 다니므로, 컨텍스트 스위칭 비용이 증가하면서 발생하는 프로그램 성능 저하로부터 자유로워지게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;동시성-프로그래밍-주의점&quot;&gt;동시성 프로그래밍 주의점&lt;/h2&gt;

&lt;p&gt;여러 고루틴이 동일한 메모리 자원에 접근하면 값을 변경시키면 &lt;strong&gt;동시성 문제&lt;/strong&gt;를 일으킵니다. 이런 문제를 해결하기 위해 한 고루틴이 접근할 때,
&lt;strong&gt;뮤텍스(mutex, 상호 배제)&lt;/strong&gt;를 이용하면 다른 고루틴이 자원에 접근하지 못하게 권한을 통제할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;mutex&quot;&gt;Mutex&lt;/h3&gt;

&lt;p&gt;뮤텍스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lock()&lt;/code&gt; 메서드를 호출해 뮤텍스를 회득하면, 이후에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lock()&lt;/code&gt; 메서드를 호출한 고루틴은 앞서 획득한 뮤텍스가 반납될 때까지 대기하게 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;// 패키지 전역 변수 뮤텍스&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutexExample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;// 뮤텍스를 확보할 때까지 대기&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// 이하 로직은 뮤텍스를 확보한 단 하나의 고루틴만 실행&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 예시의 3줄만 작성한다면 프로그램에 뮤텍스를 이용해 &lt;strong&gt;동시성 문제&lt;/strong&gt;를 해결할 수 있습니다. 그러나 또 다른 문제가 발생할 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;오직 하나의 고루틴만 공유 자원에 접근하므로, 동시성 프로그래밍으로 얻는 성능 향상을 얻을 수 없음&lt;/li&gt;
  &lt;li&gt;뮤텍스를 잘못 사용하면, &lt;strong&gt;데드락(Deadlock, 교착 상태)&lt;/strong&gt;에 빠져 무한정 대기하게 됨&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;deadlock&quot;&gt;Deadlock&lt;/h3&gt;

&lt;p&gt;하나의 프로세스가 2개 이상의 자원을 얻어야 하는 상황에서, 서로 원하는 자원이 상대방에 할당되어 무한히 다음 자원을 기다리는 데드락을 예시를 통해 발생시켜 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;math/rand&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;sync&quot;&lt;/span&gt;
	&lt;span class=&quot;s&quot;&gt;&quot;time&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;diningProblem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondName&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s 밥을 먹으려 합니다.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s %s 획득&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;firstName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s %s 획득&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secondName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s 밥을 먹습니다.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Millisecond&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

		&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Seed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UnixNano&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;

	&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;spoon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;diningProblem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;A&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spoon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;포크&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;수저&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;diningProblem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spoon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;수저&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;포크&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 예제는 실행시키면 아래와 같이 어떤 고루틴도 원하는 만큼의 뮤텍스를 확보하지 못해 무한히 대기하게 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;B 수저 획득
A 포크 획득
fatal error: all goroutines are asleep - deadlock!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;서로-다른-자원에-접근하기&quot;&gt;서로 다른 자원에 접근하기&lt;/h3&gt;

&lt;p&gt;애초에 같은 자원을 여러 고루틴이 접근하지 않는다면, 멀티코어의 이점을 얻으면서 뮤텍스로 인해 발생하는 문제도 피할 수 있습니다.
각 고루틴에게 서로 다른 자원에 접근하도록 만들기 위해 아래 2가지 방법이 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;영역 나누기 : 고루틴 간 간섭이 발생하지 않게 각각의 고루틴으로 할당된 작업만 실행&lt;/li&gt;
  &lt;li&gt;역할 나누기 : &lt;strong&gt;채널&lt;/strong&gt;을 활용해 고루틴 간의 간섭을 없애기&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Go 언어에서 동시성 프로그래밍을 도와주는 채널과 컨텍스트에 대해서는 다음 포스팅에서 다루도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;요약을 덧붙이며 이번 포스팅을 마무리 짓도록 하겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;고루틴은 경량 스레드로 컨텍스트 스위칭 비용이 발생하지 않습니다.&lt;/li&gt;
  &lt;li&gt;멀티 코어 머신에서 여러 고루틴을 사용해 성능을 증가시킬 수 있으나, 같은 메모리 영역을 조정하면 문제가 발생합니다.&lt;/li&gt;
  &lt;li&gt;뮤텍스는 동시에 고루틴 하나만 자원에 접근하도록 조정합니다.&lt;/li&gt;
  &lt;li&gt;뮤텍스를 잘못 사용하면 데드락 문제가 발생합니다.&lt;/li&gt;
  &lt;li&gt;작업 분할 방식과 역할 분할 방식으로 뮤텍스 없이 동시 프로그래밍을 가능하게 할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="backend" />
      
        <category term="programming" />
      

      
        <summary type="html">Goroutines, Concurrent Programming in Go</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">글또 7기 회고</title>
      <link href="https://heuristicwave.github.io/geultto2" rel="alternate" type="text/html" title="글또 7기 회고" />
      <published>2022-10-02T00:00:00+00:00</published>
      <updated>2022-10-02T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/geultto2</id>
      <content type="html" xml:base="https://heuristicwave.github.io/geultto2">&lt;p&gt;회고 글을 쓰며 드는 생각&lt;/p&gt;

&lt;h2 id=&quot;글또-7기를-마무리해가며-&quot;&gt;글또 7기를 마무리해가며… 🏃🏻&lt;/h2&gt;

&lt;p&gt;이번 글을 포함하여, 총 2회 제출만이 남았습니다. 본래 회고 글은 맨 마지막 제출에 작성하려 했으나, 마감 8시간을 남기고 이미 패스권은 다 소진해 계획을 수정했습니다.
해당 포스팅은 22년 5월 5일에 작성한 &lt;a href=&quot;https://heuristicwave.github.io/geultto&quot;&gt;글또 7기 다짐글&lt;/a&gt; 템플릿을 수정해 작성한 글로,
해당 글을 같이 띄워두고 보면 조금 더 재미?있지 않을까 싶습니다.&lt;/p&gt;

&lt;h2 id=&quot;-계획-점검&quot;&gt;🧩 계획 점검&lt;/h2&gt;

&lt;p&gt;지금까지 2번의 패스권 사용과 8번의 제출이 있었습니다. 다짐 글에서 아래와 같이 콘텐츠를 계획했는데, 얼마나 달성했는지 점검해 보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;기술 도서 리뷰 &lt;br /&gt;
밀린 기술 서적 부채(?)를 청산한다 했는데, 여전히 쌓여 있습니다. 한 권도 제대로 읽은 책이 없지만,
“&lt;a href=&quot;http://www.yes24.com/Product/Goods/110243880&quot;&gt;이펙티브 엔지니어&lt;/a&gt;“와 “&lt;a href=&quot;http://www.yes24.com/Product/Goods/99108736&quot;&gt;Tucker의 Go 언어 프로그래밍&lt;/a&gt;“거
을 거의 다? 읽어가니, 자체 평가로 &lt;strong&gt;B&lt;/strong&gt;를 부여하겠습니다. &lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기존 시리즈물 마감 &lt;br /&gt;
2편에 머물러 있던, ‘테라폼 더 익숙하게’ 라는 시리즈물에 추가 3편을 연재하며, 총 5편의 시리즈물을 만들었습니다.
추가로 앞서 작성했던 기존 2편도 수정을 통해 완성도를 조금 더 높였습니다. 연재가 끝난 건 아니지만, 해당 5편을 통해 &lt;a href=&quot;https://www.hashicorp.com/certification/terraform-associate&quot;&gt;Terraform Associate&lt;/a&gt; 자격증을
취득하는 데 도움이 되었으므로 &lt;strong&gt;S&lt;/strong&gt;를 부여하겠습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;관심 기술 스터디 &lt;br /&gt;
“Kubernetes, Terraform, Istio, AWS 서비스들에 대한 글을 작성하며, 성장의 기록들을 남기겠습니다.”라고 다짐했는데,
Kubernetes 1편, Terraform 3편, AWS 서비스 1편을 작성했습니다. Istio에 대해서 작성하지 못했지만, 그래도 비교적 다짐을 지킨 것 같아 &lt;strong&gt;A&lt;/strong&gt;를 제 스스로에게 주겠습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주제를 추천받아 작성 &lt;br /&gt;
최근 OIDC에 대한 글이 4번 다짐에 부합하는 것 같습니다. OIDC에 대한 글을 작성하는데, 가장 많은 시간을 쏟았으므로 &lt;strong&gt;A&lt;/strong&gt; 등급으로 평가를 마무리하겠습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;종합-평가&quot;&gt;종합 평가&lt;/h3&gt;

&lt;p&gt;4가지 항목에 대하여, 각각 B, S, A, A 등급으로 평균 &lt;strong&gt;A&lt;/strong&gt; 판정을 받았습니다. 저는 저 스스로에게 굉장히 관대한 사람인 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-잠깐&quot;&gt;✋ 잠깐!&lt;/h2&gt;

&lt;p&gt;정말 제 스스로에 대한 평가가 맞는지, 다짐 글에 다짐을 다시 보며 검토를 해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;자발적-번아웃-&quot;&gt;자발적 번아웃 🔥&lt;/h3&gt;

&lt;p&gt;자발적 번아웃이 올 정도로 열심히 글을 작성한다 했는데, 결국 오지 않은 것 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;글또에는 여러 기수를 걸쳐 지속적으로 활동하고 계신 분들이 꽤나 많습니다.
저도 이번 7기가 끝이 아니라 지속적인 활동으로 글또를 이어가고 싶습니다.
그렇지만, 7기 활동이 끝날 무렵 회고를 하는 시점에서 7기 활동 간 생산된 12편의 글로 인하여 후회 없는 활동을 하고 싶습니다.
다시 바꾸어 말하면, &lt;em&gt;“너무 힘들어서 8기는 쉬어야겠다.”&lt;/em&gt; 싶을 정도의 감정을 느끼도록 열심히 활동하고 싶습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2주마다 겪은 창작의 고통만 본다면, 후회 없는 활동에 가까운 노력을 한 것 같습니다. 그러나, 다짐 글 당시에 작성한 &lt;em&gt;“너무 힘들어서 8기는 쉬어야겠다.”&lt;/em&gt; 싶을 정도의 감정은
아직 느끼지 못했습니다. 패스권을 2회나 사용했기 때문에, 제 스스로 열심히 했다고 말하기가 부끄럽습니다.&lt;/p&gt;

&lt;h3 id=&quot;부끄러움을-늦추는-글의-유효기간-&quot;&gt;부끄러움을 늦추는 글의 유효기간 🙈&lt;/h3&gt;

&lt;p&gt;과거 저는 아래 그래프와 함께 글의 완성도와 부끄러움의 발현 시기는 양의 상관관계를 갖고 있다고 말했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/etc/graph.png&quot; alt=&quot;posting_quality&quot; /&gt;&lt;/p&gt;

&lt;p&gt;더불어 이런 목표를 가지고 이번 7기에 임했습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;작년에 제가 작성한 글 들의 경우, 아무리 길어도 대략 한 계절정도 지나면 부끄러움이 스멀스멀 올라오는것 같더군요.
그래서, 이번 활동 기간 동안에는 과거 제가 썻던 글보다 더 부끄러움이 오는 시기가 늦는 글을 작성해 보려합니다. 
활동기간이 약 6개월 정도되니 아마 5월 말에 쓰는 글에 대한 부끄러움의 정도를 7기 활동이 끝날 무렵인 회고 때 다뤄보면 좋을 것 같습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;5월부터 글을 작성하다 보니, 글또 초창기에 작성한 글들은 벌써 한 계절을 넘었습니다. 해당 글들을 지금 다시 보니 앞서 언급한 목표는 달성한 것 같습니다.
앞선 종합 평가에서 스스로에게 A를 부여했으나, 검토를 진행하다 보니 부끄러움이 몰려와 B 정도로 수정해야겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;ps&quot;&gt;P.S.&lt;/h2&gt;

&lt;p&gt;사실 이번 포스팅에는 “이펙티브 엔지니어” 독후감을 계획하고 있었지만, 썩 초안이 마음에 들지 않아 없던 일로 돌아갔습니다.
독후감 계획은 무산되었지만, 책 본문에 나온 내용을 소개하며 마치겠습니다.&lt;/p&gt;

&lt;p&gt;“우리가 집중하기 어려운 것은 앞서 말한 것처럼 연속 시간이 부족하거나 맥락이 너무 자주 전환되어서도 있지만, 
가끔은 어려운 일을 시작하는 데 필요한 &lt;strong&gt;활성화 에너지&lt;/strong&gt;를 모을 동기가 부족해서일 수도 있다.”
심리학 교수 피터 골비처(Peter Gollwitzer)는 연구에 참여하는 학생들에게 크리스마스이가 지나고 이틀 내에 휴가를 어떻게 보냈는지 에세이를 우편으로 보내라고 했다.
학생 중 절반에게는 에세이를 언제 어디서 어떻게 구체적으로 명시하게 하니, ‘실행 의사’를 구체적으로 표현한 학생 중 71%는 에세이를 우편으로 보냈다.
표현하지 않은 학생 중 에세이를 보낸 학생은 32% 뿐이었다. 행동에 아주 작은 변화를 주었을 뿐인데 완료율이 2배 이상 증가한 것이다.&lt;/p&gt;

&lt;p&gt;결과론이기는 하지만, 이번 글또 활동도 나름의 계획을 ‘다짐 글’이라는 ‘실행 의사’로 표현하니 작년보다 더 많은 글을 작성하게 된 것 같습니다. 🥲&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="uncategorized" />
      
        <category term="extracurricular" />
      

      
        <summary type="html">회고 글을 쓰며 드는 생각</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">The Journey to Know OIDC</title>
      <link href="https://heuristicwave.github.io/OIDC" rel="alternate" type="text/html" title="The Journey to Know OIDC" />
      <published>2022-09-14T00:00:00+00:00</published>
      <updated>2022-09-14T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/OIDC</id>
      <content type="html" xml:base="https://heuristicwave.github.io/OIDC">&lt;p&gt;Journey to OIDC through authentication, authorization, SAML, and OAuth.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;요즘 제 일상에서, OIDC(OpenID Connect)에 대해 많은 이야기가 오고 갔습니다. 그동안 동작 원리도 제대로 알지 못한 채 사용하고 있던 제 모습을 반성하며,
OIDC를 알아가기 위해 조사한 내용들을 다뤄보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-authentication--authorization&quot;&gt;🥾 Authentication &amp;amp; Authorization&lt;/h2&gt;

&lt;p&gt;OIDC를 향한 여정의 첫걸음은 인증과 인가입니다. 국어로도 비슷한 두 단어는 영어로도 비슷하며 다음과 같이 줄여서 표현하기도 합니다.
AuthN(인증) &amp;amp; AuthZ(인가, 권한 부여)&lt;/p&gt;

&lt;p&gt;인증과 인가에 관한 설명은 온라인에 굉장히 많지만, 저는 그중에서도 &lt;a href=&quot;https://auth0.com/docs/get-started/identity-fundamentals/authentication-and-authorization#authentication-vs-authorization&quot;&gt;&lt;strong&gt;Auth0(오스제로)&lt;/strong&gt; 사의 문서의 비교표&lt;/a&gt;를 인용하였습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Authentication&lt;/th&gt;
      &lt;th&gt;Authorization&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;사용자가 자신이 주장하는 사람이 맞는지 결정합니다.&lt;/td&gt;
      &lt;td&gt;사용자가 접근할 수 있는지 없는지 결정합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;사용자의 자격 증명이 유효한지 확인합니다.&lt;/td&gt;
      &lt;td&gt;정책과 룰을 통해 접근 여부를 확인합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;통상 인가 전 단계에 진행합니다.&lt;/td&gt;
      &lt;td&gt;통상 인증 이후 단계에 진행합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;일반적으로 &lt;strong&gt;ID Token&lt;/strong&gt;을 통해 정보를 전송합니다.&lt;/td&gt;
      &lt;td&gt;일반적으로 &lt;strong&gt;Access Token&lt;/strong&gt;을 통해 정보를 전달합니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;일반적으로 &lt;strong&gt;OIDC 프로토콜&lt;/strong&gt;에 의해 관리됩니다.&lt;/td&gt;
      &lt;td&gt;일반적으로 &lt;strong&gt;OAuth 2.0 프레임워크&lt;/strong&gt;에 의해 관리됩니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 위 비교표에 &lt;strong&gt;Bold&lt;/strong&gt;처리된 키워드가 오늘 포스팅을 이해하기 위한 핵심 용어이므로 주목해 주세요!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-oauth-20&quot;&gt;⛰ OAuth 2.0&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;OAuth 2.0 Authorization Framework&lt;/strong&gt;의 &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc6749&quot;&gt;RFC 문서&lt;/a&gt;의 Abstract 부분을 확인하면 다음과 같이 정의합니다.
&lt;em&gt;“OAuth 2.0 인가 프레임워크는 서드파티 앱들이 제한된 권한을 얻는 것을 가능하게 해줍니다.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;여러분들은 특정 서비스 회사의 애플리케이션을 이용할 때, 구글이나 페이스북으로부터 특정 권한을 받아 서비스를 이용한 경험이 있을 것입니다.
&lt;strong&gt;구글 계정&lt;/strong&gt; 정보의 &lt;a href=&quot;https://myaccount.google.com/permissions&quot;&gt;내 계정에 액세스할 수 있는 앱&lt;/a&gt;에 들어가 확인해 보시면,
내 계정이 어떤 앱들이 액세스할 수 있게 권한을 주었는지 확인 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/security/oauth.png&quot; alt=&quot;OAuth 2.0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 사진을 통해, 구글이 &lt;strong&gt;OAuth 프레임워크&lt;/strong&gt;를 사용해 Meetup, Notion, Slack과 같은 &lt;strong&gt;서드파티 앱&lt;/strong&gt;들에게
계정의 이메일 주소 확인, 개인정보 보기 등과 같은 &lt;strong&gt;제한된 권한&lt;/strong&gt;에 대하여 &lt;strong&gt;인가&lt;/strong&gt;를 해줬다는 사실을 알 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;slack으로-알아보는-oauth-20-flow&quot;&gt;Slack으로 알아보는 OAuth 2.0 Flow&lt;/h3&gt;

&lt;p&gt;OAuth에 워크플로를 알아보기 전에, 자주 언급되는 핵심 용어들을 언급하고 넘어가겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Client : 인가를 받는 애플리케이션 (배달의 민족, 야놀자, 오늘의 집 등)&lt;/li&gt;
  &lt;li&gt;Resource Server : 제어하고자 하는 자원(Protected Resource)을 가진 서버 (구글, 페이스북, 깃헙)&lt;/li&gt;
  &lt;li&gt;Resource Owner : 자원의 소유자 (end-user)&lt;/li&gt;
  &lt;li&gt;Authorization Server : AuthZ 처리를 하는 서버&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다시 &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc6749&quot;&gt;RFC 문서&lt;/a&gt;로 돌아와서 해당 프로토콜의 Flow를 앞서 보여드린 예시처럼 우리의 경험에 빗대어 설명해 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Abstract Protocol Flow&lt;/span&gt;
+--------+                               +---------------+
|        |--&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;A&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;- Authorization Request -&amp;gt;|   Resource    |
|        |                               |     Owner     |
|        |&amp;lt;-&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;B&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Authorization Grant &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;C&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Authorization Grant &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;| Authorization |
| Client |                               |     Server    |
|        |&amp;lt;-&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;D&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-----&lt;/span&gt; Access Token &lt;span class=&quot;nt&quot;&gt;-------&lt;/span&gt;|               |
|        |                               +---------------+
|        |
|        |                               +---------------+
|        |--&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;E&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-----&lt;/span&gt; Access Token &lt;span class=&quot;nt&quot;&gt;------&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;|    Resource   |
|        |                               |     Server    |
|        |&amp;lt;-&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;F&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt; Protected Resource &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;|               |
+--------+                               +---------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 A &amp;amp; B에 해당하는 Client가 Resource Owner에게 AuthZ를 요청하고 승인 절차를 Slack 로그인을 통해서 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/security/googleOAuth.png&quot; alt=&quot;login&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 이미지에서 Client인 slack은 Google과 Apple 2가지 방식의 OAuth를 제공합니다.
‘Google로 계속’이라는 버튼(A 단계, AuthZ 요청)을 누르면, slack이 계정의 이름, 이메일, 프로필 사진 등의 정보 공유를 요청했다는 것을 구글의 Authorization Server로부터 받습니다.
해당 시점의 웹브라우저 URI를 확인하면 다음과 같습니다. &lt;em&gt;(편의상 URI을 쿼리 스트링 단위로 나누고, Decode 하여 표기했습니다.)&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://accounts.google.com/o/oauth2/v2/auth/oauthchooseaccount? &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;client_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;6XXXXXXXX.apps.googleusercontent.com&amp;amp; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;redirect_uri&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://oauth2.slack.com/get-started/oauth/google/end&amp;amp; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;openid email profile&amp;amp; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;response_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;code&amp;amp; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;access_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;offline&amp;amp; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;amp; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;prompt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;consent&amp;amp; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;flowName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;GeneralOAuthFlow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;슬랙의 권한 부여의 경우, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://accounts.google.com/{이하 생략}&lt;/code&gt;이라는 Authorization Server의 주소와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;client_id&lt;/code&gt;를 포함한 8개의 querystring으로 구성되어 있습니다.
여기서 상위 4개의 querystring은 인가를 위한 &lt;strong&gt;필수 파라미터&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;client_id&lt;/code&gt; : client를 식별하기 위해 Register 단계에서 생성된 애플리케이션의 식별자&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redirect_uri&lt;/code&gt; : authorization code를 전달받을 client 서버의 URI&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scope&lt;/code&gt; : 인가할 권한을 명시&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;response_type&lt;/code&gt; : code, token 등 OAuth에 적용할 방식의 타입&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;authorization-code-grant&quot;&gt;Authorization Code Grant&lt;/h3&gt;

&lt;p&gt;캡처화면에서는 우리의 웹 브라우저를 통해 A와 B의 단계가 클릭 2번으로 끝나지만, 사실 A와 B 사이에는 더 복잡한 단계들이 숨겨져 있습니다.
아래 RFC 문서에 기재된 &lt;strong&gt;Authorization Code Grant&lt;/strong&gt;를 살펴보며 A 이후의 단계들을 살짝 보고 넘어가겠습니다. 🫣&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+----------+
| Resource |
|   Owner  |
|          |
+----------+
     ^
     |
    &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;B&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
+----|-----+          Client Identifier      +---------------+
|         -+----&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;A&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; &amp;amp; Redirection URI &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;|               |
|  User-   |                                 | Authorization |
|  Agent  -+----&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;B&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; User authenticates &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;|     Server    |
|          |                                 |               |
|         -+----&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;C&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Authorization Code &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt;&amp;lt;|               |
+-|----|---+                                 +---------------+
  |    |                                         ^      v
 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;A&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;C&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                                        |      |
  |    |                                         |      |
  ^    v                                         |      |
+---------+                                      |      |
|         |&amp;gt;---&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;D&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Authorization Code &lt;span class=&quot;nt&quot;&gt;---------&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'      |
|  Client |          &amp;amp; Redirection URI                  |
|         |                                             |
|         |&amp;lt;---(E)----- Access Token -------------------'&lt;/span&gt;
+---------+       &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;w/ Optional Refresh Token&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 승인 Flow의 User-Agent는 우리의 웹브라우저입니다. 
브라우저는 인가 서버의 URI에 querystring으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;client_id&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redirect_uri&lt;/code&gt;를 붙여 인가 서버에 전달하면(A),
인가 서버는 &lt;strong&gt;검증&lt;/strong&gt; 작업을 거쳐 &lt;strong&gt;Authorization Code&lt;/strong&gt;을 발급(C) 합니다.
&lt;strong&gt;Authorization Code&lt;/strong&gt;를 받은 브라우저는 Client에게 전달(C) 하고, Client는 다시 인가 서버에게 Code를 보내고(D)
Access Token을 돌려받습니다(E).
이후 Client는 생성된 &lt;strong&gt;Access Token&lt;/strong&gt;을 활용해 scope에 명시된 기능을 Resource Server로부터 제공받습니다.
해당 절차가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Abstract Protocol Flow&lt;/code&gt; 그림의 B ~ F에 해당합니다.&lt;/p&gt;

&lt;p&gt;지금까지 생소한 정보들을 쏟아내다 보니, 독자 여려분들이 굉장히 혼란스러울 것 같습니다. (처음 OAuth를 공부했던 제가 그랬습니다 😵‍💫)
처음부터 모든 과정을 이해하려 하면 어려우니, 대략적인 흐름만 파악하고 넘어가셔도 좋습니다. 이후 OIDC에서 예시와 함께 또 다룰 예정이거든요 🙃&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;🛎 위 2가지 Flow가 OAuth 2.0의 전체 Flow는 아닙니다. Client Register, Refresh Token 등 &lt;strong&gt;중요 개념들이 상당히 생략&lt;/strong&gt; 되어 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;openid-connectoidc&quot;&gt;OpenID Connect(OIDC)&lt;/h2&gt;

&lt;p&gt;얼렁뚱땅 OAuth를 넘기고 드디어 OpenID Connect 순서에 다 다르었습니다. OIDC를 다루기 전, &lt;strong&gt;OpenID&lt;/strong&gt;가 무엇인지 &lt;a href=&quot;https://openid.net/what-is-openid/&quot;&gt;OpenID 재단의 설명&lt;/a&gt;에서 몇 가지 살펴보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;openid&quot;&gt;OpenID&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;OpenID는 새 비밀번호를 만들 필요 없이, 기존 계정을 사용해 여러 웹사이트에 로그인할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;OpenID를 사용하면 웹사이트와 공유되는 정보의 양을 제어할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;당신의 비밀번호은 Identity provider(Idp)에게만 주어지며, Idp가 신원을 확인하므로 안전하지 않은 웹사이트가 당신의 신원을 훼손하는 것에 대해 걱정할 필요가 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚡️ OpenID 2.0은 OpenID Connect로 대체되었습니다. &lt;a href=&quot;https://openid.net/developers/libraries/obsolete/&quot;&gt;Ref. Libraries for Obsolete Specifications&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;using-oauth-20-to-access-apis&quot;&gt;Using OAuth 2.0 to Access APIs&lt;/h3&gt;

&lt;p&gt;이어서, &lt;a href=&quot;https://openid.net/connect/&quot;&gt;OpenID 재단의 설명&lt;/a&gt;의 OIDC는 다음과 같이 정의되어 있습니다.
“OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol.” OIDC가 OAuth 프로토콜의 상위 간단한 신원 계층이라는 말이 무엇을 의미할까요?
여기서 앞서 slack 예시에서 만난 OAuth의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scope&lt;/code&gt; 부분으로 거슬러 올라가 보겠습니다. (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scope=openid email profile&lt;/code&gt;) 해당 파라미터에는 인가할 리소스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;openid&lt;/code&gt;로 기재되어 있습니다.
즉, slack은 제 프로필 정보를 얻기 위해 &lt;strong&gt;OAuth 2.0&lt;/strong&gt;을 사용해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google OAuth2 API v2&lt;/code&gt;를 호출했고, 액세스하려는 API의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scope&lt;/code&gt;을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;openid&lt;/code&gt;로 지정했습니다.&lt;/p&gt;

&lt;p&gt;이해를 돕기 위해, Google Developers의 &lt;a href=&quot;https://developers.google.com/oauthplayground/&quot;&gt;OAuth 2.0 Playground&lt;/a&gt;(Client를 구축할 필요 없이, 데모 환경을 제공)를 사용해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/security/playgroundOAuth.png&quot; alt=&quot;playground&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Step1에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Google OAuth2 API v2&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scope&lt;/code&gt;으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;openid&lt;/code&gt;를 지정하고 Authorize APIs 버튼을 누르니,
Client만 Google OAuth 2.0 Playground로 바뀌고 slack 예시와 동일한 결과를 받는 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;🙈 해당 URI도 주의 깊게 살펴보면 paramter의 순서만 다를 뿐, 필수 파라미터를 포함하여 slack 예시와 비슷한 URI를 볼 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Step2에서는 Idp(여기서는 구글의 인증 서버)로부터 발급된 &lt;strong&gt;Authorization code&lt;/strong&gt;를 토큰으로 바꾸는 &lt;strong&gt;Exchange authorization code for tokens&lt;/strong&gt; 버튼을 누르면,
&lt;strong&gt;Refresh token&lt;/strong&gt;과 &lt;strong&gt;Access token&lt;/strong&gt; Idp로부터 받아 Playground 웹 페이지에 나타나게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/security/OAuthStep2.png&quot; alt=&quot;step2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이어서 전달된 Response 값을 확인해 보면, 타 OAuth 2.0 API를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scope&lt;/code&gt;으로 선택했을 때와는 다르게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_token&lt;/code&gt; 값으로 JWT 형태의 값을 받습니다.&lt;/p&gt;

&lt;h3 id=&quot;id_token&quot;&gt;id_token&lt;/h3&gt;

&lt;p&gt;OIDC는 OAuth 2.0의 상위 계층이므로 동작 원리가 OAuth 2.0과 동일합니다. 한 가지 다른 점은, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_token&lt;/code&gt; 정보가 포함되어 있다는 것입니다.
Step2에서 받은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id_token&lt;/code&gt; 값을 &lt;a href=&quot;https://jwt.io/&quot;&gt;jwt.io&lt;/a&gt;에 복사하여 Decode 한 정보를 살펴보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/security/jwt.png&quot; alt=&quot;jwt&quot; /&gt;&lt;/p&gt;

&lt;p&gt;jwt는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.&lt;/code&gt;으로 구분되어 decode 하면 아래 3가지 필드로 나뉩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;header : id 토큰의 형식, 해시 알고리즘의 종류, 암호화에 사용된 공개키 ID&lt;/li&gt;
  &lt;li&gt;payload : 사용자 인증 정보 - (발급 기관, 토큰이 발급된 앱, id 토큰 유저의 번호, 발급 시간, 만료 시간, 이메일, 이름, 프로필 사진 등)&lt;/li&gt;
  &lt;li&gt;signature : 인증 서버에 header의 공개키로 서명한 값&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;client는 payload에 담긴 사용자 정보를 활용해 유저의 인증을 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;recap&quot;&gt;Recap&lt;/h3&gt;

&lt;p&gt;여기까지 포스팅을 읽으셨다면, 앞부분에 언급했던 &lt;strong&gt;Auth0(오스제로)&lt;/strong&gt;의 인증, 인가 비교표를 떠올려주세요.
&lt;strong&gt;OAuth&lt;/strong&gt;는 &lt;strong&gt;AuthZ(인가)&lt;/strong&gt;에 초점이 맞춰 저 &lt;strong&gt;Access Token&lt;/strong&gt;으로 특정 권한을 허가해 줄 뿐 사용자의 정보는 담고 있지 않습니다.
반면, OIDC는 &lt;strong&gt;ID Token&lt;/strong&gt;을 통해 정보를 전송하며 &lt;strong&gt;AuthN(인증)&lt;/strong&gt;을 가능하게 하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;이번 포스팅은 기존에 올린 타 글들보다 많은 레퍼런스 문서들을 읽었습니다. 이미 온라인에 굉장히 잘 정리된 콘텐츠들이 많지만,
제 나름대로 재가공 하다 보니 부족한 부분들이 많습니다. 제게 많은 도움이 되었던 레퍼런스들을 아래 첨부하니, 함께 보시면 도움이 많이 될 것 같습니다.&lt;/p&gt;

&lt;p&gt;마지막으로, &lt;a href=&quot;https://www.samsungsds.com/kr/insights/oidc.html&quot;&gt;Samsung SDS의 인사이트 리포트&lt;/a&gt;에
실린 요약이 오늘의 정보들을 깔끔하게 정리해 주는 것 같아 함께 첨부하며 마치겠습니다. (요약된 문장의 단어 하나하나가 해당 기술의 특징을 잘 나태낸다는 생각이 드네요 😊)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SAML 2.0 : 2001년 OASIS에서 정의한 개방형 Authentication(인증) 및 Authorization(인가) 표준이며, 엔터프라이즈 애플리케이션의 SSO(Single Sign On)를 목적으로 XML(Extensible Markup Language) 형식으로 개발&lt;/li&gt;
  &lt;li&gt;OAuth 2.0 : 2006년 Twitter와 Google이 정의한 개방형 Authorization 표준이며, API 허가를 목적으로 JSON(Javascript Object Notation) 형식으로 개발&lt;/li&gt;
  &lt;li&gt;OIDC 2.0 : 2014년 OpenID Foundation에서 정의한 개방형 Authentication 표준이며, 컨슈머 어플리케이션의 SSO를 목적으로 JSON 형식으로 개발&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 특히나 이번 포스팅은 잘못된 내용 혹은 부적절한 설명이 있을 수도 있으니 자유롭게 지적해 주세요!
벌써 포스팅 이후 3번이나 다시 배포하게 되었네요. 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-references&quot;&gt;📚 References&lt;/h2&gt;

&lt;h3 id=&quot;ssosaml--oauth-20&quot;&gt;SSO(SAML &amp;amp; OAuth 2.0)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.okta.com/identity-101/saml-vs-oauth/&quot;&gt;SAML vs. OAuth: Comparison and Differences&lt;/a&gt; : SAML, OAuth 2.0 동작 원리 설명&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.worksmobile.com/kr/document/2001001?lang=ko&quot;&gt;NAVER WORKS Developers, SSO 개요&lt;/a&gt; : 네이버 웍스에서 SAML, OAuth 2.0 구현 방법 소개&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.oasis-open.org/committees/download.php/27819/sstc-saml-tech-overview-2.0-cd-02.pdf&quot;&gt;OASIS, SAML V2.0 Technical Overview&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;oauth-20&quot;&gt;OAuth 2.0&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc6750.txt&quot;&gt;OAuth 2.0 RFC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://opentutorials.org/course/3405&quot;&gt;생활코딩, WEB2 - OAuth 2.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;oidc&quot;&gt;OIDC&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.samsungsds.com/kr/insights/oidc.html&quot;&gt;Samsung SDS, 편의성을 높인 ID 인증 관리 - OIDC(OpenID Connect)가 주목 받는 이유&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.kakao.com/docs/latest/ko/kakaologin/common#oidc&quot;&gt;kakao developers, OIDC&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://openid.net/specs/openid-connect-core-1_0.html&quot;&gt;OpenID Connect Spec&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.daleseo.com/google-oidc/&quot;&gt;DaleSeo, 구글 OpenID Connect 사용법&lt;/a&gt; : 실습 코드 제공&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://coffeewhale.com/kubernetes/authentication/oidc/2020/05/04/auth03/&quot;&gt;k8s 인증 완벽이해 #3 - OpenID Connect&lt;/a&gt; : 쿠버네티스 인증을 설명하는 글이지만, OIDC를 이해하기 위해 아주 좋은 글&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hands-on&quot;&gt;Hands-On&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developers.google.com/oauthplayground/&quot;&gt;OAuth 2.0 Playground&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jwt.io/&quot;&gt;jwt.io&lt;/a&gt; : jwt 토큰 Decode&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app&quot;&gt;Github Docs, Building OAuth App&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.passportjs.org/concepts/authentication/oauth/&quot;&gt;passportjs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기타-도움이-되는-콘텐츠&quot;&gt;기타 도움이 되는 콘텐츠&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/1QiOXWEbqYQ&quot;&gt;얄팍한 코딩사전, 세션 VS 토큰! JWT가 뭔가요?&lt;/a&gt; : 배경 지식이 없다면, 이 영상 먼저 보는 것을 추천&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.okta.com/identity-101/whats-the-difference-between-oauth-openid-connect-and-saml/&quot;&gt;okta, What’s the Difference Between OAuth, OpenID Connect, and SAML?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="security" />
      

      
        <summary type="html">Journey to OIDC through authentication, authorization, SAML, and OAuth.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">GO Lang Interface</title>
      <link href="https://heuristicwave.github.io/GoLangInterface" rel="alternate" type="text/html" title="GO Lang Interface" />
      <published>2022-08-29T00:00:00+00:00</published>
      <updated>2022-08-29T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/GoLangInterface</id>
      <content type="html" xml:base="https://heuristicwave.github.io/GoLangInterface">&lt;p&gt;Explain the “interface” and “abstraction” of the go language.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;해당 포스팅은 &lt;a href=&quot;http://www.yes24.com/Product/Goods/99108736&quot;&gt;Tucker의 Go 언어 프로그래밍&lt;/a&gt; 20장 인터페이스를 읽고 정리한 내용임을 알립니다.
8월은 31일이고 해당 도서도 31개의 Chapter로 구성되어 있어, &lt;em&gt;하루에 1장씩 공부하면 Go 언어를 익힐 수 있을 것 같다는 호기로운 생각&lt;/em&gt;이 인터페이스를 만나고 나서 사라졌습니다.
이렇게라도 하지 않으면 올해도 Go 언어 공부를 미룰 것 같아 작성하게 되었습니다. 😵‍💫&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;interface&quot;&gt;Interface&lt;/h2&gt;

&lt;p&gt;인터페이스란 구현을 포함하지 않은 메서드 집합입니다. 구현을 포함하지 않았으므로 인터페이스는 구체화된 타입이 아닙니다. 즉, 추상화된 객체로 상호작용하기 위해 인터페이스를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;선언 방법&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;타입&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;선언&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DuckInterface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;인터페이스&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;명&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;인터페이스&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;키워드&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// 메서드 집합&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Fly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;내부에 선언된 메서드는 반드시 메서드명(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_(x int)&lt;/code&gt; 형태 불가)이 있어야 하며, 이름이 같은 메서드는 함께 있을 수 없습니다.&lt;/p&gt;

&lt;h3 id=&quot;왜-사용할까&quot;&gt;왜 사용할까?&lt;/h3&gt;

&lt;p&gt;예제를 통해 구체화된 객체가 아닌 인터페이스를 사용함으로써, 프로그램의 변경 요청에 유연하게 대응할 수 있는 방법에 대하여 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;Fedex에서 아래와 같은 패키지 코드를 제공한다고 가정하겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fedex&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FedexSender&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FedexSender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parcel&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Fedex sends&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parcel&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;, parcel)
}
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Fedex가 제공한 패키지를 이용해 상품 배송 기능을 만든다면 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;github.com/tuckersGo/musthaveGo/ch20/fedex&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SendBook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fedex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FedexSender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fedex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FedexSender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SendBook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Mastering Go&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SendBook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Mastering Rust&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 한국의 우체국이 Fedex의 패키지를 활용해 아래 코드를 작성했다고 가정하겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;github.com/tuckersGo/musthaveGo/ch20/koreaPost&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;github.com/tuckersGo/musthaveGo/ch20/fedex&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SendBook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fedex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;FedexSender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;koreaPost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PostSender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SendBook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Mastering Go&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SendBook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Mastering Rust&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 코드를 빌드 하면, 우체국과 Fedex의 타입이 달라 다음과 같은 에러를 발생시킵니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cannot use sender (variable of type *koreaPost.PostSender) as type *fedex.FedexSender in argument to SendBook&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;인터페이스로-추상화-계층-만들기&quot;&gt;인터페이스로 추상화 계층 만들기&lt;/h3&gt;

&lt;p&gt;Fedex 패키지를 오류 없이 사용하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;fedex.FedexSender{}&lt;/code&gt;와 같이 fedex 패키지의 타입과 동일하게 코드를 작성해야 합니다.
그러나 이런 방법은 Fedex 패키지에 의존성이 존재할뿐더러 관리 측면에서도 유연하지 못한 방법이므로, 인터페이스를 사용해 해당 문제를 해결해 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parcel&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Send()&lt;/code&gt; 메서드만 포함하는 인터페이스를 작성해 한국의 우체국 코드에 포함합니다.
이어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SendBook()&lt;/code&gt; 함수의 인수 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*fedex.FedexSender&lt;/code&gt;를 Sender 인터페이스로 입력받을 수 있도록 코드를 수정하면,
기존의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SendBook()&lt;/code&gt; 함수는 Sender의 인수가 Fedex 인지, UPS 인지 &lt;strong&gt;어떤 타입이든지 상관없이&lt;/strong&gt; 받아들이는 유연한 코드가 됩니다.&lt;/p&gt;

&lt;details&gt;
  &lt;summary&gt;👀 Interface를 적용한 코드 보기&lt;/summary&gt;

  &lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;github.com/tuckersGo/musthaveGo/ch20/koreaPost&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parcel&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SendBook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;koreaPost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PostSender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;SendBook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Mastering Go&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;SendBook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Mastering Rust&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

&lt;/details&gt;

&lt;p&gt;이처럼 Sender 인터페이스 정의 시 인터페이스 구현 여부를 명시적으로 드러내지 않고 메서드 포함 여부로만 결정하는 방식을 &lt;strong&gt;duck typing&lt;/strong&gt;이라고 합니다.
덕 타이핑을 통해 내부 동작을 감춰 서비스 제공자(Fedex)와 사용자(우체국) 모두 자유도가 높아졌는데, 이런 방식을 &lt;strong&gt;추상화(abstraction)&lt;/strong&gt;라고 합니다.
즉, 인터페이스는 추상화를 제공하는 &lt;strong&gt;추상화 계층(abstraction layer)&lt;/strong&gt;이며, 기존의 의존 관계를 끊는 &lt;strong&gt;디커플링(decoupling)&lt;/strong&gt;을 가능하게 해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;인터페이스-기능&quot;&gt;인터페이스 기능&lt;/h2&gt;

&lt;p&gt;지금까지 인터페이스의 기본 기능을 알아보았다면, 이제부터는 아래 3가지 기능에 대해 알아보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인터페이스를 포함하는 인터페이스&lt;/li&gt;
  &lt;li&gt;비어있는 인터페이스&lt;/li&gt;
  &lt;li&gt;인터페이스 기본값 nil&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;embedding-interface&quot;&gt;Embedding Interface&lt;/h3&gt;

&lt;p&gt;구조체에서 다른 구조체를 포함된 필드로 가질 수 있듯이 인터페이스도 다른 인터페이스를 포함할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Writer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// 2개의 인터페이스의 합쳐지면서, 같은 메서드 형식의 Close() error가 하나 메서드만 포합됩니다.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadWriter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Writer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 인터페이스는 아래 각각의 타입에 따라, 사용할 수 있는 인터페이스가 다음과 같이 달라집니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Read()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Write()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Close()&lt;/code&gt; 메서드를 포함한 타입 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader/Writer/ReadWriter&lt;/code&gt; 모두 사용 가능&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Read()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Close()&lt;/code&gt; 메서드를 포함한 타입 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader&lt;/code&gt; 만 사용 가능&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Write()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Close()&lt;/code&gt; 메서드를 포함한 타입 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Writer&lt;/code&gt; 만 사용 가능&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Read()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Write()&lt;/code&gt; 메서드를 포함한 타입 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Close()&lt;/code&gt; 메소드가 없으므로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Reader/Writer/ReadWriter&lt;/code&gt; 모두 사용 불가능&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;empty-interface&quot;&gt;Empty Interface&lt;/h3&gt;

&lt;p&gt;어떤 값이든 받을 수 있는 함수, 메서드, 변숫값을 만들 때 빈 인터페이스를 사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Sample()&lt;/code&gt; 함수는 빈 인터페이스를 인수로 받으므로, 모든 타입을 인수로 사용할 수 있습니다.
이런 특징을 활용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;switch&lt;/code&gt; 구문에서 타입별로 다른 로직을 수행하도록 할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PrintF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;s is int %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PrintF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;s is string %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PrintF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Not supported type: %T:%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;nil-interface&quot;&gt;nil Interface&lt;/h3&gt;

&lt;p&gt;인터페이스 변수의 기본값은 유효하지 않은 메모리 주소를 나타내는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;입니다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Attacker&lt;/code&gt;라는 인터페이스가 존재할 때, 아래와 같이 변수 att의 초깃값이 없으므로 해당 값은 &lt;strong&gt;nil&lt;/strong&gt;이 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;att&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Attacker&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;att&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Attack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;att의 메모리 주소는 nil이므로 &lt;strong&gt;런타임 에러&lt;/strong&gt;가 발생하므로, 인터페이스를 사용할 때는 항상 인터페이스 값이 nil이 아닌지 확인해야 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;인터페이스-변환하기&quot;&gt;인터페이스 변환하기&lt;/h2&gt;

&lt;p&gt;인터페이스 변수는 타입 변환을 통해서 &lt;strong&gt;구체화된 다른 타입&lt;/strong&gt;이나 &lt;strong&gt;다른 인터페이스&lt;/strong&gt;로 타입 변환이 가능합니다.&lt;/p&gt;

&lt;h3 id=&quot;구체화된-다른-타입으로-타입-변환하기&quot;&gt;구체화된 다른 타입으로 타입 변환하기&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;인터페이스 변수 a를 ConcreteType으로 변환하 법&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Interface&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConcreteType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;👀 구체화된 다른 타입으로 변환하는 예시&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stringer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Age&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Student Age:%d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PrintAge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stringer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stringer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                &lt;span class=&quot;c&quot;&gt;// 3. 인터페이스 변수를 *Student 타입으로 변환&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Age: %d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;                       &lt;span class=&quot;c&quot;&gt;// 1. *Student 타입 변수 s 선언&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;PrintAge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                             &lt;span class=&quot;c&quot;&gt;// 2. 변수 s를 인터페이스 인수로 제공&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main()&lt;/code&gt; 내부에 선언된 구조체 포인터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*Student&lt;/code&gt; 타입 변수 s를 선언하고(주석 1번), 주석 2번에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stringer&lt;/code&gt; 인터페이스 변수로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PrintAge()&lt;/code&gt; 함수를 호출했습니다.
이어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stringer&lt;/code&gt; 인터페이스 변수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Age&lt;/code&gt;값에 접근할 수 없으므로 주석 3번에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*Student&lt;/code&gt;로 타입이 변환되었습니다.
이어서 이러한 구조체 변환 시, 자주 만나는 컴파일 에러를 알아보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;️-타입-변환-실패-컴파일-타임&quot;&gt;❗️ 타입 변환 실패 (컴파일 타임)&lt;/h4&gt;

&lt;p&gt;인터페이스 변수를 구체화된 타입으로 변환하려면 해당 타입이 인터페이스 메서드 집합을 포함해야 합니다.
예를 들어 방금 예시에서 아래와 같이 가 &lt;strong&gt;String() 메서드&lt;/strong&gt;를 포함하지 않는다면, &lt;strong&gt;컴파일 타임&lt;/strong&gt; 에러가 발생합니다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Student&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Student Age:%d&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;즉, 위 메서드가 없다면 주석 3번과 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stringer 인터페이스&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*Student&lt;/code&gt;로 타입 변환이 불가합니다.&lt;/p&gt;

&lt;h3 id=&quot;다른-인터페이스로-타입-변환하기&quot;&gt;다른 인터페이스로 타입 변환하기&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ConcreteType&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AInterface&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BInterface&lt;/code&gt; 인터페이스 모두를 포함하고 있을 경우에는 아래와 같이 다른 인터페이스로 타입 변환이 가능합니다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AInterface&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConcreteType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BInterface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;️-타입-변환-실패-런-타임&quot;&gt;❗️ 타입 변환 실패 (런 타임)&lt;/h4&gt;

&lt;p&gt;서로 다른 인터페이스로 타입 변환 시, 서로 다른 메서드 집합을 가지고 있어도 문법적으로 문제가 발생하지는 않습니다.
그러나 경우에 따라, 타입 변환에 실패하여 &lt;strong&gt;런 타임&lt;/strong&gt; 에러가 발생할 수 있습니다.&lt;/p&gt;

&lt;details&gt;
  &lt;summary&gt;👀 다른 인터페이스로 타입 변환이 실패하는 예시&lt;/summary&gt;

  &lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Closer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Closer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;ReadFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Reader 인터페이스 변수를 Closer 인터페이스 타입으로 변환하려 하나, reader 인터페이스 변수가 가리키는 *File 타입이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Close()&lt;/code&gt; 메서드를 포함하지 않으므로 타입 변환에 실패&lt;/p&gt;
  &lt;/blockquote&gt;

&lt;/details&gt;

&lt;p&gt;&lt;strong&gt;런 타임&lt;/strong&gt; 에러가 발생하는 문제를 방지하기 위해, 아래와 같이 &lt;strong&gt;타입 변환 성공 여부&lt;/strong&gt;를 반환하는 코드를 작성할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Interface&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConcreteType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// t: 타입 변환 결과, ok: 변환 성공 여부&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;details&gt;
  &lt;summary&gt;👀 타입 변환 성공 여부를 반영한 예시&lt;/summary&gt;

  &lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Closer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;c&quot;&gt;/**
	* 한 줄로 표현
	* if c, ok := reader.(Closer); ok {}
	*/&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

&lt;/details&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;처음으로 책을 읽고 정리한 내용을 작성했는데, 이해한 내용을 바탕으로 재구성하는 것도 쉽지 않은 것 같습니다.
제가 레퍼런스로 차용한 도서의 저자가 유튜브에 공개한 강의(&lt;a href=&quot;https://www.youtube.com/TuckerProgramming&quot;&gt;Tucker Programming&lt;/a&gt;)와
요약을 덧붙이며 이번 포스팅을 마무리 짓도록 하겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;인터페이스는 구현을 포함하지 않은 메서드 집합니다.&lt;/li&gt;
  &lt;li&gt;인터페이스에서 정의 시, 메서드 포함 여부로만 결정하는 덕 타이핑을 통해 자유도 높은 프로그래밍이 가능하다.&lt;/li&gt;
  &lt;li&gt;인터페이스로 추상화 계층을 만들고 상호작용을 정의한다.&lt;/li&gt;
  &lt;li&gt;인터페이스는 인터페이스 자체를 포함하거나 빈 상태로 사용할 수 있으며, 기본값은 nil이다.&lt;/li&gt;
  &lt;li&gt;인터페이스는 구체화된 다른 타입이나 다른 인터페이스로 변환이 가능하며 타입 변환 시 에러를 고려해야 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해주세요! 😃&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="backend" />
      
        <category term="programming" />
      

      
        <summary type="html">Explain the “interface” and “abstraction” of the go language.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Declarative vs Imperative in Kubernetes</title>
      <link href="https://heuristicwave.github.io/DeclarativeVSImperativeinK8s" rel="alternate" type="text/html" title="Declarative vs Imperative in Kubernetes" />
      <published>2022-08-14T00:00:00+00:00</published>
      <updated>2022-08-14T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/DeclarativeVSImperativeinK8s</id>
      <content type="html" xml:base="https://heuristicwave.github.io/DeclarativeVSImperativeinK8s">&lt;p&gt;Kubernetes Object Management에서 발견한 명령형/선언형 방식&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Kubernetes의 리소스들을 제어하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl&lt;/code&gt; 명령어를 다루다 보니,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replace&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply&lt;/code&gt; 등과 같이 비슷하게 동작하는 명령어들에 대해서 어떤 차이가 있는지 궁금증이 생겼습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;help&lt;/code&gt; 명령어를 사용하면 각각 다음과 같이 동작한다는 정보를 얻을 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;apply : Apply a configuration to a resource by file name or stdin &lt;br /&gt;
create : Create a resource from a file or from stdin&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;해당 설명으로는 궁금증이 말끔히 해소되지 않아 공식 문서를 읽다, 
&lt;a href=&quot;https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/&quot;&gt;Kubernetes Object Management&lt;/a&gt;를 통해 머리를 스치는 깨달음을 얻었습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;kubernetes-object-management&quot;&gt;Kubernetes Object Management&lt;/h2&gt;

&lt;p&gt;문서의 첫 부분은 쿠버네티스 객체를 관리하는 기법으로 다음 3가지 기법을 소개합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Imperative commands&lt;/li&gt;
  &lt;li&gt;Imperative object configuration&lt;/li&gt;
  &lt;li&gt;Declarative object configuration&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Imperative(명령형, 절차형), Declarative(선언형)의 개념은 단어 뜻에서도 알 수 있지만, 제가 기존에 숙지하고 있던 개념을 먼저 기술하고 쿠버네티스에서는 어떻게 다른지 적어보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;declarative-vs-imperative&quot;&gt;Declarative vs Imperative&lt;/h3&gt;

&lt;p&gt;Declarative vs Imperative 개념은 프로그래밍에서도 종종 보이지만, AWS 인프라 구축에 빗대 표현해 보겠습니다.
왼쪽 현재(Current) 상태를 원하는(Desired) 상태로 만들어야 하는 상황을 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/etc/current&amp;amp;desired.png&quot; alt=&quot;CurrentAndDesired&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;strong&gt;Imperative&lt;/strong&gt;하게 구성한다면 AWS CLI와 같은 도구를 통해서 다음 &lt;strong&gt;순서&lt;/strong&gt;로 Desired State를 만듭니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;웹 서버 2개 추가&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Rule 추가&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;권한 부여&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;반면 &lt;strong&gt;Declarative&lt;/strong&gt;하게 구성한다면 Terraform과 같은 &lt;strong&gt;선언적&lt;/strong&gt; 성격을 가진 도구 다음과 같이 구성합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;웹 서버 3대, Rule, 권한 구성&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Terraform에서는 Desired State를 코드로 작성한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tf&lt;/code&gt; 형식의 파일을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply&lt;/code&gt;하여 &lt;strong&gt;Declarative&lt;/strong&gt;하게 인프라를 다룹니다.
이제 기존에 제가 제대로 알고 있지 않았던 “Kubernetes에서는 Desired State를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YAML&lt;/code&gt; 형식의 파일을 활용해 &lt;strong&gt;Declarative&lt;/strong&gt;하게 인프라를 다룬다.”
라는 반쪽짜리 정답에 대하여 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;imperative-commands&quot;&gt;Imperative commands&lt;/h3&gt;

&lt;p&gt;공식 문서의 명령형 명령의 사용법은 다음과 같은 예시와, 해당 방법은 이전 &lt;strong&gt;history를 제공하지 않으므로 일회성 작업&lt;/strong&gt;에만 추천한다고 기재되어 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create deployment nginx &lt;span class=&quot;nt&quot;&gt;--image&lt;/span&gt; nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 방법은 명령어 한 줄로 리소스를 생성할 수 있어 비교적 간편한 방법이지만, history를 제공하지 않는 점이 단점이라는 이유는 다른 방법들을 소개한 다음 설명하겠습니다. 😒&lt;/p&gt;

&lt;h3 id=&quot;imperative-object-configuration&quot;&gt;Imperative object configuration&lt;/h3&gt;

&lt;p&gt;명령형 오브젝트 구성 방법 kubectl 명령어와 create, replace 등과 같은 명령과 옵션 플래그 및 파일 이름이 필요합니다.
파일 이름 YAML 혹은 JSON 형식의 오브젝트에 대한 정의를 포함하고 있어야 합니다.&lt;/p&gt;

&lt;p&gt;명령어와 파일을 활용해 리소스를 Create/Delete/Update 하는 방법&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx.yaml
kubectl delete &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx.yaml
kubectl replace &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 방법은 Imperative Command 방식과 비교하여, YAML 파일을 활용하기 때문에 형상 관리가 가능한 이점이 생겼습니다.
그렇지만 직접 YAML 파일을 작성해야 하는 추가적인 단계가 발생했습니다.&lt;/p&gt;

&lt;p&gt;여기서 저는 의문이 들었습니다. Terraform의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tf&lt;/code&gt;과 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YAML&lt;/code&gt; 파일로 Desired 상태를 만드는 방법이 왜 &lt;strong&gt;명령형&lt;/strong&gt; 오브젝트 구성 방법인지.
이 떡밥도 마지막 방법을 소개한 이후 회수하도록 하겠습니다. 🤫&lt;/p&gt;

&lt;h3 id=&quot;declarative-object-configuration&quot;&gt;Declarative object configuration&lt;/h3&gt;

&lt;p&gt;공식문서에서는 해당 기법을 설명하기 위해 아래와 같은 쉽게 이해되지 않는 설명이 기재되어 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When using declarative object configuration, a user operates on object configuration files stored locally,
however the user does not define the operations to be taken on the files.
Create, update, and delete operations are automatically detected per-object by kubectl.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;declarative object configuration 방식을 사용할 때, 사용자는 로컬에 저장된 개체 구성 파일에 대해 작업하지만,
사용자는 파일에 대한 작업들을 정의하지는 않는다. Create, update, and delete 작업들은 객체별로 자동으로 감지된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, Imperative object configuration 방식에서는 사용자가 Create, Update, Delete를 명령어로 결정했습니다. (사용자의 판단)
Declarative object configuration 방식에서는 오로지 구성 파일에서 정의한 대로 삭제 혹은 생성 등이 작동합니다. (정의한 대로 작동)&lt;/p&gt;

&lt;p&gt;Declarative object configuration 방식은 configuration 파일이 위치한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/config&lt;/code&gt; 디렉토리에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diff&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply&lt;/code&gt; 명령어로 작동시킵니다.
구성 파일이 여러 개라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-R&lt;/code&gt; 옵션을 함께 넣어줍니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl diff &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; configs/    // 정의한 config 적용에 대한 결과 예상
kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; configs/   // 정의한 config 적용
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diff&lt;/code&gt;는 마치 테라폼의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plan&lt;/code&gt;과 같은 역할을, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply&lt;/code&gt; 테라폼의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply&lt;/code&gt;처럼 동작합니다 :) &lt;br /&gt;
여담으로 저는 과거 테라폼관련 포스팅 당시 apply 하기 전, plan 명령어의 중요성을 여러 번 강조했었는데,
정작 저는 kubernetes manifest 파일들을 적용할 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--dry-run&lt;/code&gt; 옵션만으로 리소스가 현재 상태에 미치는 영향을 판단하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diff&lt;/code&gt;를 적극적으로 사용하지 않았던 모습이 부끄럽습니다. 😣&lt;/p&gt;

&lt;p&gt;추가적으로 Imperative object configuration 방식과 Declarative object configuration 방식을 혼용하여 사용하는 예시를 통해,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply&lt;/code&gt;와 반대되는 명령어가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt;가 아닌 이유를 생각해 보며 다음 Annotations 차례로 넘어가겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx.yaml   // Declarative object configuration 방식으로 리소스 생성
kubectl delete &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx.yaml  // Imperative object configuration 방식으로 리소스 삭제
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;annotations&quot;&gt;Annotations&lt;/h2&gt;

&lt;p&gt;위 3가지 방식을 설명하면서 공식 문서에 기재된 각 방식의 Trade-offs에 대한 내용들을 대부분 생략했습니다.
상태에 대한 기록을 설명하지 않았기 때문이죠. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl apply&lt;/code&gt;는 이전의 호출 이후 &lt;strong&gt;구성의 변경 사항을 판별&lt;/strong&gt;하기 위해 리소스에 어노테이션을 첨부합니다.
이를 통해, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Declarative object configuration&lt;/code&gt; 방식은 History를 기록하며 Audit도 가능하게 되었습니다.&lt;/p&gt;

&lt;p&gt;해당 어노테이션은 쿠버네티스 오브젝트 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;metadata&lt;/code&gt; 하위 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;annotations&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl.kubernetes.io/last-applied-configuration&lt;/code&gt; 이름으로 현재 리소스에 적용된 config 값들이 저장되어 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply&lt;/code&gt; 명령어로 생성한 리소스를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl get {Type} {Name} -o yaml&lt;/code&gt; 명령어로 조회하면 어떤 값이 적용되었는지 조회 가능합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;-lab&quot;&gt;🧑‍🔬 Lab&lt;/h3&gt;

&lt;p&gt;앞서 설명한 object configuration 방식들을 직접 체험할 수 있도록 예제 코드를 작성해 두었습니다.
아래 실험용 Manifest 파일들을 생성하고 다음 명령어로 어노테이션을 조회해보세요. &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl get deploy nginx-declarative -o yaml | grep &quot;annotations&quot;&lt;/code&gt;&lt;/p&gt;

&lt;details&gt;
  &lt;summary&gt;🪜 Imperative object configuration&lt;/summary&gt;
  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt; &amp;gt; nginx_imperative.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-imperative
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx-imperative
  template:
    metadata:
      labels:
        app: nginx-imperative
    spec:
      containers:
      - image: nginx
        name: nginx-imperative
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF
&lt;/span&gt;kubectl create &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx_imperative.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/details&gt;

&lt;details&gt;
  &lt;summary&gt;📣 Declarative object configuration&lt;/summary&gt;
  &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt; &amp;gt; nginx_declarative.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-declarative
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx-declarative
  template:
    metadata:
      labels:
        app: nginx-declarative
    spec:
      containers:
      - image: nginx
        name: nginx-declarative
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF
&lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; nginx_declarative.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/details&gt;

&lt;h3 id=&quot;-오답-노트&quot;&gt;🖍 오답 노트&lt;/h3&gt;

&lt;p&gt;이제 떡밥 회수 겸, 기존에 제가 제대로 알고 있지 않았던 “Kubernetes에서는 Desired State를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YAML&lt;/code&gt; 형식의 파일을 활용해 &lt;strong&gt;Declarative&lt;/strong&gt;하게 인프라를 다룬다.”
라는 반쪽짜리 정답에 대하여 오답노트를 적어보겠습니다.&lt;/p&gt;

&lt;p&gt;Declarative 도구인 Terraform은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tf&lt;/code&gt;에 상태를 &lt;strong&gt;정의함과 동시&lt;/strong&gt;에 apply 이후 자동으로 생성되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tfstate&lt;/code&gt; 파일에 &lt;strong&gt;현재 상태가 함께 기록&lt;/strong&gt;됩니다.
Kubernetes에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YAML&lt;/code&gt;로 정의하지만, 적용된 config 정보가 포함되지 않은 방법은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Imperative object configuration&lt;/code&gt; 방식입니다.
이제서야 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply&lt;/code&gt; command를 사용해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last-applied-configuration&lt;/code&gt; 가 함께 기록되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Declarative object configuration&lt;/code&gt; 방식을 제대로 이해한 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;글을 마치며 주저리주저리 떠오른 생각들을 적어보겠습니다.&lt;/p&gt;

&lt;p&gt;저는 매번 블로그 포스팅 소재를 고민합니다. 실제로 10개의 포스팅 아이디어가 떠오르지만, 블로그 글로 탄생하는것은 1~2개 뿐입니다.
실제로 뭔가 트러블 슈팅에 대한 글을 작성하려고 해도, 나중에 공식문서를 보니 더 잘 작성된 것 같은 느낌을 종종 받습니다.
또한 애초에 문서를 제대로 읽었다면, 해당 이슈를 만나지 않았을 것만 같아 업로드를 포기하는 글이 있었습니다.&lt;/p&gt;

&lt;p&gt;이런 고민이 너무 길어져 주기적인 업로딩이 늦어지는 점은 명확한 단점인 것 같습니다. (아 물론! 매일 현실과 타협하여 미루다보니 늦어지는게 가장 큰 이유겠지만요)&lt;/p&gt;

&lt;p&gt;그래서 이번에는 기술블로그를 2주에 1편을 쓰자는 약속을 지키기 위해서… &lt;a href=&quot;https://kubernetes.io/docs/concepts/overview/working-with-objects/object-management/&quot;&gt;Kubernetes Object Management&lt;/a&gt;를 해설과 동시에,
이번 포스팅은 제가 공식문서를 어떻게 읽는지 읽으면서 어떤 생각을 하는지에 대한 사고의 흐름을 담으며 이해하는 과정을 담았습니다.&lt;/p&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해주세요! 😃&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="devops" />
      
        <category term="container" />
      

      
        <summary type="html">Kubernetes Object Management에서 발견한 명령형/선언형 방식</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Terraform Tips 5 - Import</title>
      <link href="https://heuristicwave.github.io/TerraformTips5" rel="alternate" type="text/html" title="Terraform Tips 5 - Import" />
      <published>2022-07-23T00:00:00+00:00</published>
      <updated>2022-07-23T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/TerraformTips5</id>
      <content type="html" xml:base="https://heuristicwave.github.io/TerraformTips5">&lt;p&gt;Terraform 더 익숙하게 5 - Import&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;IaC를 도입하기 위해 구축 단계부터 코드로 인프라를 작성할 수도 있지만, 기 구축된 인프라를 코드화할 수도 있습니다.
이때 사용하는 Terraform의 기능이 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Import&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;하지만 저는 구축 단계에도 종종 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Import&lt;/code&gt; 기능을 활용합니다. Terraform으로 코드를 작성하기 위해 &lt;a href=&quot;https://registry.terraform.io/providers/hashicorp/aws/latest/docs&quot;&gt;registry.terraform.io&lt;/a&gt;에서
가이드 하는 대로 코드를 작성하는 것이 생각보다 어려운 작업이기 때문이죠. 🥲&lt;/p&gt;

&lt;p&gt;그래서 저는 먼저 구축하고자 하는 인프라를 콘솔상에서 구성한 다음, 구축에 필요한 Attribute 들을 파악합니다.
그다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Import&lt;/code&gt;를 사용해 동작하는 IaC 코드를 얻고 수정합니다.
즉, 저는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Import&lt;/code&gt; 기능을 Cheat Sheet처럼 사용하고 있습니다. 😅&lt;/p&gt;

&lt;p&gt;이번 포스팅에서는 실제 제가 Cheat Sheet으로 활용하는 &lt;em&gt;‘Import 시나리오’&lt;/em&gt;를 통해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Import&lt;/code&gt;를 학습해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-조립은-분해의-역순&quot;&gt;⏮ 조립은 분해의 역순&lt;/h2&gt;

&lt;p&gt;AWS Systems Manager의 인스턴스 운영 자동화를 위한 State Manager 기능을 사용하기 위해 &lt;a href=&quot;https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ssm_association&quot;&gt;문서&lt;/a&gt;를
확인해 보았지만, 다음과 같은 사용법 만이 기재되어 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-terraform highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;resource&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;aws_ssm_association&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;example&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;aws_ssm_document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;targets&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;key&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;InstanceIds&quot;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;values&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;aws_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해당 코드를 apply 해도 무수한 Error만 만날 뿐 빠르게 진도가 나가지 않기에, 우선 AWS 웹 콘솔을 활용해 인스턴스 운영 자동화를 위한 State Manager 기능을 구현해 두었습니다.&lt;/p&gt;

&lt;h3 id=&quot;0️⃣-준비-작업&quot;&gt;0️⃣ 준비 작업&lt;/h3&gt;

&lt;p&gt;이번 포스팅의 작업 공간(~/terraform)을 생성하고 해당 위치에서 아래 코드 블록을 터미널에 복사합니다. (리소스가 위치한 리전 명에 맞게 세팅해 주세요)&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt; &amp;gt; provider.tf
provider &quot;aws&quot; {
  region  = &quot;ap-northeast-2&quot;
}
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이후, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform init&lt;/code&gt; 명령어를 실행시켜주세요.&lt;/p&gt;

&lt;h3 id=&quot;1️⃣-skeleton-code-작성&quot;&gt;1️⃣ Skeleton Code 작성&lt;/h3&gt;

&lt;p&gt;웹 콘솔로 작업한 State Manager를 코드화하기 위해 아래와 같이 Skeleton Code를 작성합니다.
(import 후, 생성되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tfstate&lt;/code&gt;를 담는 일종의 빵틀을 제작하는 단계입니다.)&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt; &amp;gt; main.tf
resource &quot;aws_ssm_association&quot; &quot;copycat&quot; {}
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2️⃣-import-configuration&quot;&gt;2️⃣ Import Configuration&lt;/h3&gt;

&lt;p&gt;사용법(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform import [options] ADDRESS ID&lt;/code&gt;)에 따라 아래 명령어를 실행시키면 &lt;strong&gt;root directory&lt;/strong&gt;에 미리 생성된 인프라가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tfstate&lt;/code&gt; 파일에 담깁니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;terraform import aws_ssm_association.copycat &amp;lt;Association ID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;생성된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tfstate&lt;/code&gt; 파일을 확인하면 json 형태로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aws_ssm_association&lt;/code&gt; resource block에 작성해야 하는 각종 Config 값들을 알 수 있습니다.
그러나, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show&lt;/code&gt; 명령어를 사용해 HCL Syntax에 맞춰 &lt;strong&gt;human-readable&lt;/strong&gt;한 형태로 출력합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;terraform show &lt;span class=&quot;nt&quot;&gt;-no-color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; main.tf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;본래 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-no-color&lt;/code&gt; 옵션은 coloring 작업을 비활성화하지만, Editor에 format 맞추기 위해 필수적으로 해당 옵션을 사용합니다.&lt;/p&gt;

&lt;h3 id=&quot;3️⃣-modify-arguments&quot;&gt;3️⃣ Modify Arguments&lt;/h3&gt;

&lt;p&gt;이제서야 얼추 모양을 갖춘 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.tf&lt;/code&gt;의 &lt;strong&gt;resource block&lt;/strong&gt;에는 리소스가 인프라에 &lt;strong&gt;반영된 이후 단계에 생성되는 각종 result&lt;/strong&gt; 값(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;arn&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;association_id&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;)
이 포함되어 있습니다. 해당 값들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform plan&lt;/code&gt; 명령어를 수행해 Error 메시지에 명시되므로 지워야 하는 Arguments들을 찾아 코드를 수정합니다.&lt;/p&gt;

&lt;p&gt;이때, Instancd Id, IAM Role ARN 등과 같이 &lt;strong&gt;절대적인 값&lt;/strong&gt;도 &lt;strong&gt;재사용 가능한 변수&lt;/strong&gt;로 처리하는 것이 좋습니다.
해당 작업을 마치고 나면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plan&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply&lt;/code&gt; 명령어를 수행하여 다음 메시지를 얻으면 정상적으로 Import 작업이 완료된 것입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Apply complete! Resources: 0 added, 0 changed, 0 destroyed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-import-into-module&quot;&gt;🥵 Import into Module&lt;/h2&gt;

&lt;p&gt;지금까지 학습한 절차는 단순 &lt;strong&gt;Resource&lt;/strong&gt;에 Import 시키므로 비교적 수월한 과정이었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Resource configured with count &lt;br /&gt;
➡️ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform import 'aws_instance.baz[0]' i-abcd1234&lt;/code&gt; &lt;br /&gt;
Resource configured with for_each &lt;br /&gt;
➡️ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform import 'aws_instance.baz[&quot;example&quot;]' i-abcd1234&lt;/code&gt; &lt;br /&gt;
Module &lt;br /&gt;
➡️ &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform import module.foo.aws_instance.bar i-abcd1234&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Module을 Import 하는 절차도 Resource와 동일하지만, 명백한 &lt;strong&gt;한계점&lt;/strong&gt;이 있습니다.&lt;/p&gt;

&lt;p&gt;흔하게 사용되는 &lt;a href=&quot;https://registry.terraform.io/modules/terraform-aws-modules/ec2-instance/aws/latest&quot;&gt;ec2-instance&lt;/a&gt; 모듈을 사용한다고 가정하겠습니다.
Resource 때와 동일하게 아래와 같은 Skeleton Code를 작성하고 Import 명령어를 수행하는 부분은 동일합니다. (1️⃣ &amp;amp; 2️⃣ 과정 동일)&lt;/p&gt;

&lt;div class=&quot;language-terraform highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ec2_instance&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;terraform-aws-modules/ec2-instance/aws&quot;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;~&amp;gt; 3.0&quot;&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;single-instance&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ec2_instance&lt;/code&gt;가 되고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bar&lt;/code&gt;는 해당 모듈의 &lt;strong&gt;aws_instance&lt;/strong&gt;에서 정의한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this&lt;/code&gt;가 됩니다.&lt;/p&gt;

&lt;p&gt;문제는 &lt;strong&gt;3️⃣ Modify Arguments&lt;/strong&gt; 단계에서 발생합니다. Single Resource에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plan&lt;/code&gt;을 통해 수정해야 하는 &lt;strong&gt;Arguments&lt;/strong&gt;들을 알 수 있지만, 
module에서 skeleton code 이외에 더 기재해야 하는 variable 값들을 알 수 없습니다.
즉, module import 이후 생성되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tfstate&lt;/code&gt; 파일의 &lt;strong&gt;json 값을 일일이 확인&lt;/strong&gt;하여 module의 &lt;strong&gt;input parameter에 해당하는 값&lt;/strong&gt;들을 알아내 &lt;strong&gt;하나씩 다 기재&lt;/strong&gt;하는 방법 외에는 
온전하게 import 명령어를 사용할 수 없습니다.&lt;/p&gt;

&lt;p&gt;Reverse Engineering으로 원래의 코드를 완벽하게 재현하기 어려운 것처럼, 구성이 복잡한 모듈은 Reverse Terraforming이 매우 어렵습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-reverse-terraform-open-source&quot;&gt;🌏 Reverse Terraform Open Source&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;2️⃣ Import Configuration&lt;/strong&gt; 단계에서 수행한 작업은 &lt;a href=&quot;https://github.com/GoogleCloudPlatform/terraformer&quot;&gt;Terraformer&lt;/a&gt;(작성 시점 기준 ★ 8.1k),
&lt;a href=&quot;https://github.com/dtan4/terraforming&quot;&gt;Terraforming&lt;/a&gt;(업데이트 종료) 등과 같은 오픈소스 도구를 활용할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;⚠️ 고려 사항&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;Terraformer&lt;/strong&gt;는 &lt;a href=&quot;https://github.com/GoogleCloudPlatform/terraformer/blob/master/docs/aws.md#profiles-support&quot;&gt;AWS configuration Profiles Select&lt;/a&gt;와 &lt;a href=&quot;https://github.com/GoogleCloudPlatform/terraformer/blob/master/docs/aws.md#attribute-filters&quot;&gt;Attribute filters&lt;/a&gt;과 같은 편리한 기능들을 제공합니다. &lt;br /&gt;
그러나 &lt;a href=&quot;https://github.com/GoogleCloudPlatform/terraformer/blob/master/docs/aws.md#supported-services&quot;&gt;terraformer AWS 리소스 지원 범위&lt;/a&gt;에서도 확인할 수 있다시피,
위에서 작업한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aws_ssm_association&lt;/code&gt;과 같이 지원하지 않는 리소스들도 존재합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;마지막으로 Import Workflow를 다시 한번 정리하면서 마치겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Import 대상(이미 프로비저닝 된 인프라)이 되는 Skeleton Code 작성&lt;/li&gt;
  &lt;li&gt;Write Config : Import &amp;amp; Show 명령어 수행&lt;/li&gt;
  &lt;li&gt;Modify Arguments&lt;/li&gt;
  &lt;li&gt;Plan &amp;amp; Apply&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;지금까지 테라폼 더 익숙하게 Import 편을 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;📚 References&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Terraform Documentation &lt;a href=&quot;https://www.terraform.io/cli/commands/import&quot;&gt;Import Command&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Hashicorp Tutorial 문서 &lt;a href=&quot;https://learn.hashicorp.com/tutorials/terraform/state-import?in=terraform/state&quot;&gt;Import Terraform Configuration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Terraform Tips&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips1&quot;&gt;Module &amp;amp; Output&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips2&quot;&gt;Data &amp;amp; Index&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips3&quot;&gt;Refresh &amp;amp; Replace&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips4&quot;&gt;Move (Refactoring)&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips5&quot;&gt;Import&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="devops" />
      
        <category term="terraform" />
      

      
        <summary type="html">Terraform 더 익숙하게 5 - Import</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">ECS on EC2 Walkthrough</title>
      <link href="https://heuristicwave.github.io/ECS_Walkthrough" rel="alternate" type="text/html" title="ECS on EC2 Walkthrough" />
      <published>2022-07-03T00:00:00+00:00</published>
      <updated>2022-07-03T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/ECS_Walkthrough</id>
      <content type="html" xml:base="https://heuristicwave.github.io/ECS_Walkthrough">&lt;p&gt;EC2 기반의 ECS를 다루기 위한 사소한 지식들 톱아보기!&lt;/p&gt;

&lt;h1 id=&quot;intro&quot;&gt;Intro&lt;/h1&gt;

&lt;p&gt;당장 Amazon Elastic Container Service(이하 ECS)를 운영해야 하지만, 공식 문서를 다 읽기에는 벅차고 중요한 운영 포인트들을 빠르게 학습하기 위해 아래와 같은 요소들을 다룹니다.
&lt;em&gt;ECS 마스터&lt;/em&gt;가 될 수 있는 모든 것을 다루는 것은 아니지만, 최소한의 고민해 볼 만한 지점들을 다뤄보았습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Amazon ECS Container Agent&lt;/li&gt;
  &lt;li&gt;ECS 리소스 할당&lt;/li&gt;
  &lt;li&gt;ECS Scaling&lt;/li&gt;
  &lt;li&gt;ECS 서비스 구성&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-ecs-container-agent&quot;&gt;🕋 ECS Container Agent&lt;/h2&gt;

&lt;p&gt;EC2 기반의 ECS를 운용하기 위해서는 &lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html&quot;&gt;ECS 최적화 AMI&lt;/a&gt;를 사용해야 합니다.
일반 EC2 인스턴스로도 ECS를 운용할 수 있지만, ECS 최적화 AMI를 사용하는 것이 관리와 운용 측면에서 유리합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;예를 들어 Docker를 운영하다 보면, 미사용 상태인 컨테이너 이미지가 쌓여나가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prune&lt;/code&gt; 명령어를 통해 이미지를 정리해 주어야 합니다.
이런 상황에서 컨테이너 에이전트는 다양한 &lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/automated_image_cleanup.html#automated_image_cleanup_parameters&quot;&gt;자동화된 이미지 정리&lt;/a&gt; 옵션을 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ECS-optimized AMI에는 &lt;a href=&quot;https://github.com/aws/amazon-ecs-agent&quot;&gt;Amazon ECS Container Agent&lt;/a&gt;가 기본적으로 포함되어 있습니다.
ECS 인스턴스를 부트스트랩 하는 단계에서 EC2의 user data를 사용해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/ecs/ecs.config&lt;/code&gt;에 configuration parameters을 전달합니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 환경 변수를 지정하지 않아도 default 값이 지정되어 있어 운용상의 큰 문제는 없지만,
&lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html&quot;&gt;공식 문서&lt;/a&gt;를 확인해 필요한 configuration 들을 파악해야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;' &amp;gt;&amp;gt; /etc/ecs/ecs.config
ECS_CLUSTER=MyCluster
ECS_LOGLEVEL=debug
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다양한 configuration 중, 운영 환경(GPU, SPOT, 서비스 등)에 따라 필요한 Configuration 값들이 다르겠지만 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECS_RESERVED_MEMORY&lt;/code&gt;는 고려하여 지정하는 것이 좋습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 인스턴스의 모든 메모리를 테스크에 배정한다면, 테스크와 중요한 시스템 프로세스 사이에서 메모리 경합이 발생할 수 있습니다.
이를 예방하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECS_RESERVED_MEMORY&lt;/code&gt; configuration을 사용해 메모리를 예약함으로써 풀에서 할당 가능한 메모리를 제외할 수 있습니다.
필요로 하는 최소한의 요구 메모리가 정의되어 있지는 않지만, 저는 문서의 예시처럼 256MiB로 사용하고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-ecs-resource&quot;&gt;🎛 ECS Resource&lt;/h2&gt;

&lt;p&gt;ECS는 3가지 범주로 리소스를 설정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;🥇 &lt;strong&gt;Container instance&lt;/strong&gt; : ECS 클러스터를 이루고 있는 EC2 인스턴스의 유형 &lt;br /&gt;
🥈 &lt;strong&gt;Task Size&lt;/strong&gt; : Task Definitions을 통해 정의하는 Size &lt;br /&gt;
🥉 &lt;strong&gt;Container Size&lt;/strong&gt; : Task Definitions의 Container 정의 부분에서 정의하는 Size &lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 ECS on EC2에서는 Task Size와 Container Size 방식 중 선택 가능하지만, Fargate 방식에서 Task Size는 필수입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;container-definitions&quot;&gt;Container definitions&lt;/h3&gt;

&lt;p&gt;Container Size의 리소스 할당 파라미터는 각각 다음과 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt; 명령어 옵션에 매핑됩니다. &lt;br /&gt;
&lt;strong&gt;cpu&lt;/strong&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--cpu-shares&lt;/code&gt;, &lt;strong&gt;memory&lt;/strong&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--memory&lt;/code&gt;(hard) / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--memory-reservation&lt;/code&gt;(soft)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;CPU : Unit 단위 (1,024개의 CPU 유닛은 vCPU 1개), Memory : Hard/Soft Limits&lt;/em&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hard 🆚 Soft&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Hard : 명시한 값만큼 리소스 제약이 생깁니다. 때문에 클러스터 인스턴스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker stats&lt;/code&gt; 명령어를 조회하면 LIMIT 값이 &lt;strong&gt;Hard로 명시한 값&lt;/strong&gt;으로 표시됩니다.&lt;/li&gt;
  &lt;li&gt;Soft : 명시한 값이 클러스터 인스턴스에 예약됩니다. Soft limit이므로 컨테이너 메모리 사용량이 명시한 값의 제한을 넘겨 사용 가능합니다.
Hard와 달리, 클러스터 인스턴스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker stats&lt;/code&gt; 명령어를 조회하면 LIMIT 값이 &lt;strong&gt;클러스터 인스턴스의 총 자원&lt;/strong&gt;으로 표시됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;🥇로 갈수록 더 상위 개념이며, Task Definitions에서는 🥈, 🥉을 활용해 리소스를 제어합니다.
세밀한 제어를 하고 싶다면 🥈, 🥉을 모두 사용하여 제어할 수 있으나,
🥉 사용해야 하는 특별한 이유가 없다면 🥈만을 사용해 리소스를 제어하는 것이 용이합니다.&lt;/p&gt;

&lt;h3 id=&quot;actual-available-memory&quot;&gt;Actual available memory&lt;/h3&gt;

&lt;p&gt;16GiB의 인스턴스를 프로비저닝해도 &lt;strong&gt;실제 사용 가능한 메모리(15318 MiB)&lt;/strong&gt;는 더 적습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Amazon EC2&lt;/th&gt;
      &lt;th&gt;인스턴스&lt;/th&gt;
      &lt;th&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free -m&lt;/code&gt;&lt;/th&gt;
      &lt;th&gt;Registered&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;c5.2xlarge&lt;/td&gt;
      &lt;td&gt;16384 MiB&lt;/td&gt;
      &lt;td&gt;15574 MiB&lt;/td&gt;
      &lt;td&gt;15318 MiB&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;EC2 인스턴스와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free -m&lt;/code&gt; 명령어로 확인한 차이&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ECS 플랫폼 메모리 오버헤드와 OS 커널이 차지하는 메모리로 인해 차이가 발생합니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free -m&lt;/code&gt; 명령어로 확인한 메모리와 컨테이너 인스턴스(registered)의 차이&lt;/p&gt;

&lt;p&gt;&lt;em&gt;컨테이너 에이전트를 설정할 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECS_RESERVED_MEMORY=256&lt;/code&gt;으로 설정한 만큼 차이가 발생합니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-ecs-scaling&quot;&gt;🏘 ECS Scaling&lt;/h2&gt;

&lt;p&gt;ECS의 Scaling 방법은 2가지로 정의할 수 있습니다. 해당 스케일링 기법은 선택 사항이 아니라, 2가지 모두를 고려해 적용해야 합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Service에 의하여 Task가 Scaling 되는 Horizontal Autoscaling&lt;/li&gt;
  &lt;li&gt;CapacityProvider에 의하여 컨테이너 인스턴스가 Scaling 되는 Cluster Autoscaling&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;service-auto-scaling&quot;&gt;Service auto scaling&lt;/h3&gt;

&lt;p&gt;서비스 스케일링은 또다시 &lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/userguide/service-autoscaling-targettracking.html&quot;&gt;Target tracking&lt;/a&gt;과 &lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/userguide/service-autoscaling-stepscaling.html&quot;&gt;Step&lt;/a&gt; scaling으로 나뉩니다.&lt;/p&gt;

&lt;p&gt;Target tracking은 &lt;strong&gt;CPU/Memory 사용률&lt;/strong&gt; 및 &lt;strong&gt;ALB 요청 횟수&lt;/strong&gt;를 기반의 정책이 있으며, Step 방식은 &lt;strong&gt;Alarm을 활용한 Custom&lt;/strong&gt; 정책들을 작성할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 Step scaling policies의 문서 첫 문장은 다음과 같습니다. &lt;br /&gt;
Although Amazon ECS service auto scaling supports using Application Auto Scaling step scaling policies, we recommend using target tracking scaling policies instead. &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Step scaling은 조금 더 공격적인 정책이 필요할 때 대안으로 사용하고, Service auto scaling은 복수의 조정 정책을 동시에 활용할 수 있으므로 하나의 정책에 의존하기보다는 복수의 정책을 사용해 보다 세밀한 Scaling 정책을 만드는 게 어떨까요? 🧐&lt;/p&gt;

&lt;h3 id=&quot;cluster-auto-scaling&quot;&gt;Cluster auto scaling&lt;/h3&gt;

&lt;p&gt;Service auto scaling에 컨테이너 인스턴스 내 자원을 다 할당했을 경우, CapacityProvider EC2 Auto Scaling을 활용해 클러스터 자원을 확보합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/blogs/containers/deep-dive-on-amazon-ecs-cluster-auto-scaling/&quot;&gt;AWS 블로그&lt;/a&gt;에 자세한 작동원리가 나오므로 꼭 한번 읽어보시기 바랍니다.
해당 내용을 요약하자면 &lt;strong&gt;Capacity Provider&lt;/strong&gt;를 Cluster 인프라를 관리합니다.
이를 위해 &lt;strong&gt;CapacityProviderReservation 지표&lt;/strong&gt;가 존재하고 사전에 설정한 &lt;strong&gt;Target capacity %&lt;/strong&gt;(1~100사이의 값)에 맞춰 EC2 AutoScalingGroup(ASG)에 Trigger가 작동합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CapacityProviderReservation(%) = M(현재 인스턴스+추가 요청 인스턴스)/N(현재 인스턴스) * 100(%)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;만약 Target capacity을 100으로 지정했을 때, 현재 Cluster의 Node 개수가 3이고 CapacityProviderReservation가 200이라면
CapacityProviderReservation를 목표치(Target capacity)인 100에 맞추기 위해 3개의 EC2를 Scale-out 시킵니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ To create an empty Auto Scaling group, set the desired count to zero. &lt;br /&gt; 
Capacity Provider는 &lt;strong&gt;Desired&lt;/strong&gt; 값이 &lt;strong&gt;0&lt;/strong&gt;인 ASG와 연결되어야 합니다. 또한 CapacityProvider에 의하여 관리형 조정을 enable 한 상태에서,
ASG를 &lt;strong&gt;수동&lt;/strong&gt;으로 수정한다면 CapacityProviderReservation 계산에 영향을 미칠 수 있으므로 &lt;strong&gt;지양&lt;/strong&gt;해야 합니다. 
&lt;br /&gt;&lt;br /&gt;
🚫️ DO NOT EDIT OR DELETE &lt;br /&gt;
해당 메시지는 Service &amp;amp; Cluster Scaling이 CloudWatch에 자동으로 생성한 TargetTracking의 주석 내용입니다.
관리형 정책의 기능을 활용 시, 조금 더 세밀한 Scaling 필요하다면 알람 Trigger의 빈도가 아닌 다른 방안을 고민하도록 합니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-ecs-service-configuration&quot;&gt;🧮 ECS Service Configuration&lt;/h2&gt;

&lt;h3 id=&quot;deployment-configuration&quot;&gt;Deployment Configuration&lt;/h3&gt;

&lt;p&gt;ECS 서비스에서 &lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DeploymentConfiguration.html&quot;&gt;배포와 관련된 설정&lt;/a&gt;을 보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;maximumPercent&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minimumHealthyPercent&lt;/code&gt;가 있습니다.
비슷하면서도 헷갈리기 쉬운 2개의 설정값 개념은 손에 잡힐듯하면서도 쉽게 잡히지 않는 것 같아, 예시 상황을 적어보았습니다.😂&lt;/p&gt;

&lt;p&gt;&lt;em&gt;해당 개념이 조금 더 와닿을 수 있도록, 공식 문서를 읽어보시고 아래 상황이 어떨지 예상해 보세요!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;🧑🏻‍💻는 ECS &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;maximumPercent&lt;/code&gt;가 200%, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minimumHealthyPercent&lt;/code&gt;가 100%로 설정되어 있으며, Rolling update 방식을 사용하고 있다.
현재 ver01을 운영하는 🧑🏻‍💻는 실수로 오류를 포함한 ver02를 배포했다. 기존 Task 4개일 때, 어떤 상황이 벌어지는가?&lt;/p&gt;

&lt;details&gt;
  &lt;summary&gt;🖍 정답 보기&lt;/summary&gt;

  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minimumHealthyPercent&lt;/code&gt;가 100%이기 때문에 ver02에 프로비저닝되고 정상 상태로 확인될 때까지 ver01은 중단되지 않습니다.
ver02는 &lt;strong&gt;running&lt;/strong&gt; 상태로 진입하지 못해 &lt;strong&gt;provisioning-pending-stopped&lt;/strong&gt; 단계를 반복합니다.
이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;maximumPercent&lt;/code&gt;가 200%임에 따라 ver02 Task는 4개와 ver01 Task 4개(합, 최대 8개)의 Task가 동시에 올라올 수 있습니다.&lt;/p&gt;

&lt;/details&gt;

&lt;h3 id=&quot;task-placement&quot;&gt;Task Placement&lt;/h3&gt;

&lt;p&gt;ECS의 서비스가 컨테이너 인스턴스에 Task를 배치하는 전략은 아래와 같이 3가지 분류됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binpack&lt;/code&gt;: CPU 또는 메모리를 최소화하기 위해 유휴 자원을 고려한 배치&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;random&lt;/code&gt; : 무작위 배치&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spread&lt;/code&gt; : ami-id, availability-zone, instance-type, os-type 등을 고려한 배치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 3가지 전략은 단독 혹은 복수로 선택되어 사용될 수 있으며, 가용성을 확보하기 위해 AZ를 고려하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AZ + binpack&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AZ + spread&lt;/code&gt;와 같이 사용되기도 합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;쿠버네티스를 공부해 보신 분이라면, 해당 전략은 마치 k8s의 nodeSelector와 비슷하게 동작합니다.&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;🔊 CapacityProviderReservation에 영향을 미치는 배포 설정과 배치 전략 &lt;br /&gt;
ECS 서비스 설정에서 언급한 배포 설정과 배치 전략은 가용성 문제와 직결되고 이는 비용 문제로도 이어집니다.
앞서 언급 한 CapacityProviderReservation 계산에 활용되는 M 값에 배포 설정과 배치 전략이 영향을 미친다는 점을 유의하세요!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;이번 포스팅을 통해 ECS와 관련된 내용을 정리하다 보니, AWS 내의 다른 오케스트레이션 서비스인 EKS의 운용 전략과 무척이나 비슷하다는 느낌을 지울 수 없었습니다.
쿠버네티스의 HPA 최적화, Pod 배치 및 리소스 할당 전략과 같은 포인트들은 운영을 하며 지속적으로 관리하는 관리 대상인 만큼,
위에 언급된 ECS의 운영 포인트들도 &lt;strong&gt;서비스를 배포한 이후에도 지속적으로 관심&lt;/strong&gt;을 가져야 하는 포인트임을 강조하며 마칩니다.&lt;/p&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      

      
        <summary type="html">EC2 기반의 ECS를 다루기 위한 사소한 지식들 톱아보기!</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Terraform Tips 4 - Move (Refactoring)</title>
      <link href="https://heuristicwave.github.io/TerraformTips4" rel="alternate" type="text/html" title="Terraform Tips 4 - Move (Refactoring)" />
      <published>2022-06-07T00:00:00+00:00</published>
      <updated>2022-06-07T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/TerraformTips4</id>
      <content type="html" xml:base="https://heuristicwave.github.io/TerraformTips4">&lt;p&gt;Terraform 더 익숙하게 4 - Move (Refactoring)&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://heuristicwave.github.io/TerraformTips3&quot;&gt;지난 3편&lt;/a&gt;에서는 &lt;em&gt;코드의 변경 없이&lt;/em&gt; 형상을 유지하는 기법 중 하나인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Refresh&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Replace&lt;/code&gt;에 대하여 알아보았습니다.
4편에서는 &lt;em&gt;코드를 변경(Refactoring)&lt;/em&gt; 할 때 형상을 유지하는 방법인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Move&lt;/code&gt;와 관련된 기능들을 소개합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-moving-resources&quot;&gt;🤹 Moving Resources&lt;/h2&gt;

&lt;p&gt;Terraform으로 정의한 인프라는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform.tfstate&lt;/code&gt;에 기록되며, real-world의 객체는 특정 &lt;a href=&quot;https://www.terraform.io/cli/state/resource-addressing&quot;&gt;리소스 주소&lt;/a&gt;와 연결되어 있습니다.
그래서 정의한 인프라 코드를 변경 후, 적용하면 real-world의 객체와 상태가 변경됩니다.
코드로 정의된 실제 인프라를 운영하고 있다면, 코드 리팩토링 시 발생하는 리소스 변경 지점을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;State&lt;/code&gt; 명령어를 활용해 해소해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Commands&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state mv&lt;/code&gt; : real-world 객체와 연결된 리소스 주소를 변경&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state rm&lt;/code&gt; : real-world 객체를 파괴하지 않고 코드로 정의한 리소스 관리 대상 제거&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state replace-provider&lt;/code&gt; : 재생성 없이, 새로운 provider에 기존 리소스 전&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-state-mv&quot;&gt;🛠 state mv&lt;/h3&gt;

&lt;p&gt;위 3가지 명령어 중에서도 가장 활용도가 높은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state mv&lt;/code&gt; 명령어의 예시들을 확인해 보겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.terraform.io/cli/commands/state/mv#example-rename-a-resource&quot;&gt;리소스 이름 재정의&lt;/a&gt; : 
리팩토링 과정에서 정의된 리소스 명을 변경하는 경우 &lt;br /&gt; 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform state mv {ResourceType}.{ExistingName} {ResourceType}.{ChangedName}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.terraform.io/cli/commands/state/mv#example-move-a-resource-into-a-module&quot;&gt;리소스를 모듈로 이동&lt;/a&gt; : 
루트에 위치한 리소스를 child 모듈에 포함시켜 리팩토링 하는 경우 &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform state mv {Type}.{Name} module.{ModuleName}.{Type}.{Name}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.terraform.io/cli/commands/state/mv#example-move-a-module-into-a-module&quot;&gt;모듈을 다른 모듈로 이동&lt;/a&gt; &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform state mv module.{ModuleName} module.{ParentModuleName}.module.{ModuleName}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.terraform.io/cli/commands/state/mv#example-move-a-particular-instance-of-a-resource-using-count&quot;&gt;meta-argument &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for_each&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt;로 정의된 특정 리소스 교체&lt;/a&gt; &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform state mv {ResourceType}.{Before}[0] {ResourceType}.{After}[0]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;️-moved-statements&quot;&gt;🏃️ Moved statements&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://heuristicwave.github.io/TerraformTips3&quot;&gt;지난 3편&lt;/a&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;refresh&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;taint&lt;/code&gt;가 가진 한계점으로 인하여
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--refresh-only&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replace&lt;/code&gt;가 나왔듯이, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state mv&lt;/code&gt;도 한계점이 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform taint&lt;/code&gt; command informs Terraform that a particular object has become degraded or damaged. &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;problems-with-terraform-state-mv&quot;&gt;&lt;a href=&quot;https://youtu.be/bDgoGBusX0k?t=178&quot;&gt;Problems with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform state mv&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;위 링크로 첨부한 Terraform 1.1 버전이 출시하면서 발표한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Move&lt;/code&gt; 기능에 대한 발표 자료를 보면 아래 3가지 이유로 한계점을 다룹니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Risky and error prone&lt;/li&gt;
  &lt;li&gt;Terraform Cloud users couldn’t refactor within core workflows&lt;/li&gt;
  &lt;li&gt;Module authors couldn’t coordinate changes themselves&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3가지의 한계점이 언급되었지만, 결국 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;refresh&lt;/code&gt; 때와 마찬가지로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plan&lt;/code&gt;을 통한 예측 과정이 없는 동일한 이유로 위와 같은 문제가 발생한다는 사실을 알 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;refactoring&quot;&gt;&lt;a href=&quot;https://www.terraform.io/language/modules/develop/refactoring&quot;&gt;Refactoring&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;앞서 언급한 한계점들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plan&lt;/code&gt; 기능이 없는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mv&lt;/code&gt; 명령어 대신 기존의 테라폼 문법에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;moved&lt;/code&gt; block이 추가되며 해소되었습니다.
아래 예시는 &lt;a href=&quot;https://www.terraform.io/language/modules/develop/refactoring#moved-block-syntax&quot;&gt;공식 문서&lt;/a&gt;에 기재된 예제입니다.&lt;/p&gt;

&lt;div class=&quot;language-terraform highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;locals&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;instances&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;tomap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;big&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;instance_type&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;m3.large&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;small&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;instance_type&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;t2.medium&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;resource&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;aws_instance&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;for_each&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;instances&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;instance_type&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;instance_type&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# (other resource-type-specific configuration)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;moved&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;aws_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;to&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;aws_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;small&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;moved&lt;/code&gt; block에 변경 전후 상태를 선언하여, 기존 상태를 바꾸는 명령조차도 코드로 선언하여 상태를 바꾸는 행위를 코드화했습니다.&lt;/p&gt;

&lt;h3 id=&quot;️-고려사항&quot;&gt;⁉️ 고려사항&lt;/h3&gt;

&lt;p&gt;클라우드 환경에서 운영을 하다 보면 최적화 과정 중 리소스 스펙(인스턴스 종류, 타입)이 자주 변경됩니다.
그럼 아래와 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;moved&lt;/code&gt; 블록이 체인과 같이 길어지게 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-terraform highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Block 1&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;moved&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;aws_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;to&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;aws_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Block 2&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;moved&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;aws_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;to&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;aws_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 오히려 사용하지 않는 혹은 &lt;em&gt;중복된 코드를 지우고 로직을 이해하기 쉽게 디자인&lt;/em&gt;해야 하는 &lt;strong&gt;리팩토링과는 멀어지게&lt;/strong&gt; 됩니다.
그러므로 AWS 리소스의 경우 &lt;strong&gt;단순 스펙 변경&lt;/strong&gt;과 같은 작업은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Launch templates&lt;/code&gt;을 사용하는 게 좋습니다.
이처럼 AWS 서비스 내에서 &lt;strong&gt;형상 관리&lt;/strong&gt; 기능을 제공하는 서비스를 활용해, moved 블록을 생성하는 작업을 최소화해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;지금까지 리팩토링 작업을 위해 필수적으로 사용되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state mv&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;moved&lt;/code&gt; syntax 사용법을 알아보았습니다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Move&lt;/code&gt;의 탄생 과정에서 선언형 도구인 테라폼의 목적에 맞게 진화해나가는 모습과 초기 설계의 중요성을 고민해 볼 수 있었던 좋은 기회였습니다.
여담으로 저는 테라폼 버전이 0.12일 때 다루기 시작했는데, 2년 만에 버전 1.2.2에 이르며 정착해나가는 과정을 보니
사용자도 IaC 도구의 철학을 이해하며 함께 성장하는 기분에 감격스럽습니다.&lt;/p&gt;

&lt;p&gt;지금까지 테라폼 더 익숙하게 Move(Refactoring) 편을 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Terraform Tips&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips1&quot;&gt;Module &amp;amp; Output&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips2&quot;&gt;Data &amp;amp; Index&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips3&quot;&gt;Refresh &amp;amp; Replace&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips4&quot;&gt;Move (Refactoring)&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips5&quot;&gt;Import&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="devops" />
      
        <category term="terraform" />
      

      
        <summary type="html">Terraform 더 익숙하게 4 - Move (Refactoring)</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Terraform Tips 3 - Refresh &amp;amp; Replace</title>
      <link href="https://heuristicwave.github.io/TerraformTips3" rel="alternate" type="text/html" title="Terraform Tips 3 - Refresh &amp; Replace" />
      <published>2022-05-28T00:00:00+00:00</published>
      <updated>2022-05-28T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/TerraformTips3</id>
      <content type="html" xml:base="https://heuristicwave.github.io/TerraformTips3">&lt;p&gt;Terraform 더 익숙하게 3 - Refresh &amp;amp; Replace&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;IaC(Infrastructure as Code)를 운용하며 중요하게 생각하는 포인트 중 하나는, &lt;strong&gt;코드로 정의한 형상&lt;/strong&gt;과 &lt;strong&gt;실제 인프라의 형상&lt;/strong&gt;을 동일하게 유지하는 것입니다.
Terraform에서는 &lt;strong&gt;Configuration Drift&lt;/strong&gt;(정의한 형상과 달라지는 경우)를 방지하기 위해 다양한 명령어를 제공합니다.
이번 포스팅에서는 형상을 유지하는 다양한 기법 중 하나인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Refresh&lt;/code&gt;와 비슷하면서도 헷갈리는 개념인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Replace&lt;/code&gt;에 대하여 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;️-refresh&quot;&gt;♻️ Refresh&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;refresh&lt;/code&gt; 명령어는 Configuration Drift가 발생했을 때, 현재 상태를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform.tfstate&lt;/code&gt;에 반영해 현재 인프라의 상태로 최신화시키는 명령어입니다.
문서에는 다음과 같이 기재되어 있지만, 처음 접한다면 무엇을 말하는지 쉽게 와닿지 않습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform refresh&lt;/code&gt; command reads the current settings from all managed remote objects and updates the Terraform state to match. &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform refresh&lt;/code&gt; 명령어는 원격 객체의 현재 상태를 읽어 Terraform state와 일치시킵니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Refresh 명령어는 다음과 같은 상황에서 사용합니다. 클라우드 환경에서 클러스터를 운용하면 인스턴스의 Scale이 변화함에 따라 인스턴스 ID 값도 변합니다.
이 경우 코드로 정의한 상태는 프로비저닝 당시 시점을 기억하지만, 실제 인프라의 현상은 최신 인스턴스의 상태를 가지고 있으므로 Drift가 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/terraform/state.png&quot; alt=&quot;state&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 상황에서 Refresh 명령어로 &lt;em&gt;코드의 상태와 인프라의 현재 상태를 일치&lt;/em&gt;시킬 수 있지만, 해당 명령어는 &lt;strong&gt;deprecate&lt;/strong&gt; 되었습니다. 왜냐하면 관리자가 무엇이 변경되는지 알지 못하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tfstate&lt;/code&gt;가 최신화되기 때문입니다.
그래서 테라폼 v0.15.4.에서부터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plan&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-refresh-only&lt;/code&gt; 옵션을 제공하기 시작했습니다.&lt;/p&gt;

&lt;h3 id=&quot;refresh-only&quot;&gt;–refresh-only&lt;/h3&gt;

&lt;p&gt;왼쪽은 프로비저닝 당시 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tfstate&lt;/code&gt;입니다. 오른쪽은 해당 환경을 콘솔에서 health check를 하는 간격을 120초로 변경한 화면입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/terraform/refresh.png&quot; alt=&quot;refresh&quot; /&gt;&lt;/p&gt;

&lt;p&gt;의도적으로 Drfit 상황을 만들었기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform plan --refresh-only&lt;/code&gt; 명령어로 점검하면 다음과 같이 어떤 리소스 객체가 변경될 것인지 확인 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/terraform/refresh-only.png&quot; alt=&quot;refresh-only&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 사진에서는 elb의 AutoScalingGroup 내의 인스턴스가 바뀌어 최신화됨과, 제가 의도적으로 콘솔에서 변경한 health_check 값을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이처럼 항상 IaC의 형상을 변경하기 전, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plan&lt;/code&gt;을 통한 사전 검토 기능을 제공하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--refresh-only&lt;/code&gt; 옵션이 제공되었습니다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plan&lt;/code&gt;으로 문제없음을 확인했다면, 이어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform apply --refresh-only&lt;/code&gt; 명령어로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tfstate&lt;/code&gt;를 최신화 시킵니다.&lt;/p&gt;

&lt;h3 id=&quot;️-주의&quot;&gt;⚠️ 주의&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tfstate&lt;/code&gt;는 Refresh로 최신화되었지만, 여전히 코드로 정의한 interval 값은 180입니다.
그러므로 코드로 정의된 부분을 변경하지 않은 상황에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform apply&lt;/code&gt; 명렁어를 치면, 현재 120의 interval 값이 180으로 원복 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;️-taint&quot;&gt;☠️ Taint&lt;/h2&gt;

&lt;p&gt;Replace를 설명하기 앞서, 기존 테라폼에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;taint&lt;/code&gt;라는 명령어가 있습니다. 문서에는 다음과 같이 기재되어 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform taint&lt;/code&gt; command informs Terraform that a particular object has become degraded or damaged. &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform taint&lt;/code&gt; 명령어는 특정 객체가 저하되거나 손상되었음을 Terraform에 알립니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Taint 명령어는 &lt;strong&gt;인프라를 정의한 코드는 그대로&lt;/strong&gt;인 상태에서 &lt;strong&gt;리소스만 교체&lt;/strong&gt;할 경우에 사용합니다.
저의 경우 스파이크성 트래픽을 갑자기 받아 로드밸런서의 성능이 저하되었을 때, ELB를 교체한 경험이 있습니다.&lt;/p&gt;

&lt;p&gt;이런 상황에서 성능이 저하된 혹은 &lt;strong&gt;교체가 필요한 리소스&lt;/strong&gt; 객체만을 on/off 방식으로 &lt;strong&gt;주석 처리 및 해제&lt;/strong&gt;하며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply&lt;/code&gt; 명령어로 교체할 수 있지만,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;taint(교체 리소스를 마킹)&lt;/code&gt; 명령어로 교체하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;untaint(교체 리소스 마킹 해제)&lt;/code&gt; 명령어로 교체할 필요가 없다고 명령할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그러나 위와 같은 워크플로우는 테라폼 v0.15.2.에서 deprecate 되었고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-replace&lt;/code&gt; 옵션을 제공하며 더 직관적인 사용자 경험을 제공하게 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;--replace&quot;&gt;🌗 -replace&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-replace&lt;/code&gt; 옵션은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;taint&lt;/code&gt; 명령어와 동일하게 작용하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;untaint&lt;/code&gt; 명령어를 칠 필요가 없습니다.
코드는 그대로지만 리소스 객체가 변경되는 Replace 명령어 사용법은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;terraform apply &lt;span class=&quot;nt&quot;&gt;-replace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;aws_instance.example[0]&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;교체할 리소스 인자값를 찾기 위해, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform state list&lt;/code&gt; 명령어로 target을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/terraform/replace.png&quot; alt=&quot;replace&quot; /&gt;&lt;/p&gt;

&lt;p&gt;💡 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-replace&lt;/code&gt; 옵션 역시, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--refresh-only&lt;/code&gt; 옵션과 동일하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plan&lt;/code&gt; 명령어와 함께 적용하여 변경 지점을 미리 파악하고
변경되는 리소스에 대한 검토를 하는 습관을 들입시다!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;Refresh와 Replace 비슷하면서도 전혀 다른 두 명령어의 변천사를 확인하며 인프라의 동일한 형상을 유지하기 위한 방법을 알아보았습니다.
이번 포스팅에서 언급한 방법 외에도 형상을 일치시키는 방법들이 존재하지만, 위 2가지 명령어만 제대로 활용하면 대부분의 인프라의 형상이 달라지는 사태를 예방할 수 있습니다. 
IaC에서는 항상 형상을 변경하기 전, 변경되는 리소스에 대한 검토를 하는 습관이 매우 중요하다는 것을 강조하며 이번 3편을 마칩니다.&lt;/p&gt;

&lt;p&gt;지금까지 테라폼 더 익숙하게 Refresh &amp;amp; Replace 편을 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Terraform Tips&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips1&quot;&gt;Module &amp;amp; Output&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips2&quot;&gt;Data &amp;amp; Index&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips3&quot;&gt;Refresh &amp;amp; Replace&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips4&quot;&gt;Move (Refactoring)&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips5&quot;&gt;Import&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="devops" />
      
        <category term="terraform" />
      

      
        <summary type="html">Terraform 더 익숙하게 3 - Refresh &amp;amp; Replace</summary>
      

      
      
    </entry>
  
</feed>
