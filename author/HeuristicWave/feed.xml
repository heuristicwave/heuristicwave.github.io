<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://heuristicwave.github.io/author/HeuristicWave/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://heuristicwave.github.io/" rel="alternate" type="text/html" />
  <updated>2022-05-09T01:43:51+00:00</updated>
  <id>https://heuristicwave.github.io/author/HeuristicWave/feed.xml</id>

  
  
  

  
    <title type="html">Heuristic Wave Blog | </title>
  

  
    <subtitle>Careful Writer</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">글또 7기 다짐글</title>
      <link href="https://heuristicwave.github.io/geultto" rel="alternate" type="text/html" title="글또 7기 다짐글" />
      <published>2022-05-05T00:00:00+00:00</published>
      <updated>2022-05-05T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/geultto</id>
      <content type="html" xml:base="https://heuristicwave.github.io/geultto">&lt;p&gt;글또 7기 다짐글 입니다.&lt;/p&gt;

&lt;h2 id=&quot;글또를-시작하며-&quot;&gt;글또를 시작하며… 🏃🏻&lt;/h2&gt;

&lt;p&gt;저는 최근 &lt;strong&gt;‘글 쓰는 개발자 모임, 글또’&lt;/strong&gt; 7기로 활동할 수 있는 기회를 얻었습니다. &lt;br /&gt;
글또가 어떤 활동인지는 &lt;a href=&quot;https://www.notion.so/zzsza/ac5b18a482fb4df497d4e8257ad4d516&quot;&gt;글또 페이지&lt;/a&gt; 에서 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;글또의 존재는 2기 때부터 알고 있었지만, 스스로 활동을 하기에는 아직 부족하다 생각되어
지난 1년간 한 달에 글 1편씩을 작성하는 습관을 만들고 나서 7기에 가입하게 되었습니다.&lt;/p&gt;

&lt;p&gt;활동은 올해 5월부터 10월까지 약 6개월간 활동하게 되는데요, 첫 미션으로 다짐글 작성이라는 주제를 받았습니다.
그 동안 이 기술 블로그에 개인적인 얘기는 담지 않을뿐더러,
평상시에도 일기와 같은 자신의 마음(다짐 포함)을 적어 본 적이 없어 글을 써 내려가기가 부끄럽네요.&lt;/p&gt;

&lt;h2 id=&quot;-계획&quot;&gt;🧩 계획&lt;/h2&gt;

&lt;p&gt;계획하고 있는 콘텐츠는 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;기술 도서 리뷰 &lt;br /&gt;
현재 제 책상 위에는 구입해두고 읽지 못한 책들이 꽤나 쌓였습니다.
‘컨테이너 보안’, ‘Go 언어를 활용한 네트워크 프로그래밍’ 등 밀린 기술 서적 부채(?)를 청산하도록 노력하겠습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기존 시리즈물 마감 &lt;br /&gt;
작년 제 블로그에 ‘테라폼 더 익숙하게’ 라는 시리즈물을 연재하기로 하고 게으른 탓 2편 밖에 작성하지 못했습니다.
머릿속에만 남아있는 후속 글 들을 작성해 시리즈물 다운 글을 작성해 보도록 하겠습니다. &lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;아직 2편 밖에 없는 작고 초라한 나의 시리즈물&lt;/em&gt;
&lt;img src=&quot;../../assets/built/images/post/etc/series.png&quot; alt=&quot;posting_quality&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;주제를 추천받아 작성 &lt;br /&gt;
저는 어떻게 보면 글을 작성하는 것보다, 주제를 선정하는 게 더욱 어려운 것 같습니다.
글또를 통해 비슷한 직군의 엔지니어 분들이 고민하는 혹은 알고 싶은 주제들이 무엇인지 파악해 관련 글을 작성하고 싶습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;-다짐&quot;&gt;✋ 다짐&lt;/h2&gt;

&lt;h3 id=&quot;자발적-번아웃-&quot;&gt;자발적 번아웃 🔥&lt;/h3&gt;

&lt;p&gt;글또에는 여러 기수를 걸쳐 지속적으로 활동하고 계신 분들이 꽤나 많습니다.
저도 이번 7기가 끝이 아니라 지속적인 활동으로 글또를 이어가고 싶습니다.
그렇지만, 7기 활동이 끝날 무렵 회고를 하는 시점에서 7기 활동 간 생산된 12편의 글로 인하여 후회 없는 활동을 하고 싶습니다.
다시 바꾸어 말하면, &lt;em&gt;“너무 힘들어서 8기는 쉬어야겠다.”&lt;/em&gt; 싶을 정도의 감정을 느끼도록 열심히 활동하고 싶습니다.&lt;/p&gt;

&lt;h3 id=&quot;부끄러움을-늦추는-글의-유효기간-&quot;&gt;부끄러움을 늦추는 글의 유효기간 🙈&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://heuristicwave.github.io/archive&quot;&gt;이 페이지&lt;/a&gt; 를 보면 제가 한 해 동안, 작성한 글들이 나옵니다. &lt;br /&gt;
당시에도 한편 한편 공들여 작성하며 &lt;em&gt;“이정도면 꽤나 괜찮은 글 아닐까?”&lt;/em&gt; 라는 생각을 종종했었는데,
시간이 지난 시점에 다시 읽어보면 부끄럽다는 생각이 들때가 있습니다.&lt;/p&gt;

&lt;p&gt;온라인 어디선가 본 내용인데, 좋은 글을 작성한 것으로 평가 받는 작가들도 과거 자신이 작성한 글을 보면 부끄럽다고 합니다.
이런 것들을 보면 자신의 글을 부끄러워 하는게 당연한 것일 수도 있는데, 다음과 같은 생각이 들었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/etc/graph.png&quot; alt=&quot;posting_quality&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그래프에서 보이다시피, 글의 완성도와 부끄러움의 발현 시기는 양의 상관관계를 갖고 있다고 생각합니다.
작년에 제가 작성한 글 들의 경우, 아무리 길어도 대략 한 계절정도 지나면 부끄러움이 스멀스멀 올라오는것 같더군요.&lt;/p&gt;

&lt;p&gt;그래서, 이번 활동 기간 동안에는 과거 제가 썻던 글보다 더 부끄러움이 오는 시기가 늦는 글을 작성해 보려합니다.
활동기간이 약 6개월 정도되니 아마 5월 말에 쓰는 글에 대한 부끄러움의 정도를 7기 활동이 끝날 무렵인 회고 때 다뤄보면 좋을 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="extracurricular" />
      

      
        <summary type="html">글또 7기 다짐글 입니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Export cloudwatch log data to Amazon S3 using lambda</title>
      <link href="https://heuristicwave.github.io/Export_data_to_S3_Lambda" rel="alternate" type="text/html" title="Export cloudwatch log data to Amazon S3 using lambda" />
      <published>2022-04-07T00:00:00+00:00</published>
      <updated>2022-04-07T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/Export_data_to_S3_Lambda</id>
      <content type="html" xml:base="https://heuristicwave.github.io/Export_data_to_S3_Lambda">&lt;p&gt;본 글은 Cloudwatch Logs groups의 데이터를 Lambda를 사용해 주기적으로 S3로 export 하는 방법을 다룹니다.&lt;/p&gt;

&lt;h1 id=&quot;intro&quot;&gt;Intro&lt;/h1&gt;

&lt;p&gt;글을 시작하기 앞서, &lt;a href=&quot;https://noob2geek.in/2021/06/18/export-aws-cloudwatch-logs-to-s3-using-lambda-functions-in-node-js/&quot;&gt;Shraddha Paghdar - Export AWS CloudWatch logs to S3 using lambda functions in Node.js&lt;/a&gt;
를 참고하여 해당 글을 작성했음을 알립니다. 본격적으로 방법을 소개하기 앞서, Cloudwatch Logs groups의 데이터를 Lambda를 사용해 주기적으로 S3로 export 하기 위한 플로우는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/background/exportLambda.png&quot; alt=&quot;imageBuilder&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Amazon EventBridge에 정의한 Rule에 의해 Lambda를 호출합니다.&lt;/li&gt;
  &lt;li&gt;이후 람다가 지정한 CloudWatch의 Logs에 적재된 데이터를 찾습니다.&lt;/li&gt;
  &lt;li&gt;2번에 연속되어 이관될 대상의 로그들이 S3로 이관됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;-workshop&quot;&gt;📜 Workshop&lt;/h2&gt;

&lt;h3 id=&quot;1️⃣-log를-담을-bucket-및-정책-생성하기&quot;&gt;1️⃣ Log를 담을 Bucket 및 정책 생성하기&lt;/h3&gt;

&lt;p&gt;Amazon S3 콘솔 화면에 접속해 Log들이 담길 Bucket을 생성하고 이어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Permissions&lt;/code&gt;에서 S3 버킷에 대한 권한을 설정합니다.
해당 방법은 &lt;a href=&quot;https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/S3ExportTasksConsole.html&quot;&gt;공식 문서, 1단계와 3단계&lt;/a&gt; 자세히 설명되어 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 공식 문서 3단계에서 기재된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;random-string&lt;/code&gt;은 필요에 의한 경우 사용하세요. 해당 글에서는 편의상 생략하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;2️⃣-lambda-생성하기&quot;&gt;2️⃣ Lambda 생성하기&lt;/h3&gt;

&lt;h4 id=&quot;step-1--lambda가-사용하는-iam-role--policy-생성&quot;&gt;Step 1 : Lambda가 사용하는 IAM Role &amp;amp; Policy 생성&lt;/h4&gt;

&lt;p&gt;Lambda가 Log를 Export 할 수 있도록 다음 정책을 생성합니다.
IAM에서 Create policy를 선택하고 아래 JSON을 복사하여 붙여 넣고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cloudwatch_export_task&lt;/code&gt;라는 이름으로 정책을 생성합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;Version&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;2012-10-17&quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&quot;Statement&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&quot;Effect&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;Allow&quot;&lt;/span&gt;,
            &lt;span class=&quot;s2&quot;&gt;&quot;Action&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;logs:CreateExportTask&quot;&lt;/span&gt;,
            &lt;span class=&quot;s2&quot;&gt;&quot;Resource&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;arn:aws:logs:{Region}:{AccountNumber}:*&quot;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Lambda에 권한을 부여해 주기 위해서 IAM &amp;gt; Roles &amp;gt; Create Role을 선택합니다.
Use case로 Lambda를 선택하고 앞서 생성한 정책을 부여한 뒤, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;export_S3_lambda&lt;/code&gt;라는 이름으로 Role을 생성합니다.&lt;/p&gt;

&lt;h4 id=&quot;step-2--코드-작성&quot;&gt;Step 2 : 코드 작성&lt;/h4&gt;

&lt;p&gt;Lambda 콘솔 화면에서 아래와 같이 빈칸을 채우고, Step 1에서 만들어둔 role을 부여해 람다 함수를 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/guide/exportLambda.png&quot; alt=&quot;baseimage&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 만약, Export 역할을 수행하는 &lt;strong&gt;람다 함수가 생성하는 로그&lt;/strong&gt;를 수집하고 싶을 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create a new role with basic Lambda permissions&lt;/code&gt;을
선택하고 Console에 의해 자동적으로 생성되는 Role에 Step 1에서 만든 정책을 부여하면 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이어서 아래 코드를 복사하여 상황에 맞는 인자 값을 넣어주고 Deploy 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Parameter&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;region : 로그 그룹과 대상 버킷은 동일 리전에 위치&lt;/li&gt;
  &lt;li&gt;destination : 로그가 이관되는 대상 버킷&lt;/li&gt;
  &lt;li&gt;logGroupName : Cloudwatch Log group 이름&lt;/li&gt;
  &lt;li&gt;destinationPrefix : 1️⃣ 에서 언급한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;random-string&lt;/code&gt; 값&lt;/li&gt;
  &lt;li&gt;from/to : Lambda 함수가 호출 되는 시점을 기준으로, from/to 기간의 로그 그룹들을 export&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AWS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;aws-sdk&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cloudconfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;2014-03-28&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;region&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;region&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cloudwatchlogs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AWS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;CloudWatchLogs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cloudconfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;destination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;bucket-name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;logGroupName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;log-groups-name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;destinationPrefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;86400&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cloudwatchlogs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createExportTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;statusCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;statusCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;501&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 테스트 버튼을 눌러 결과값을 보면 taskId 값이 생성되고 S3에 로그가 이관된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;3️⃣-eventbridge-트리거-생성하기&quot;&gt;3️⃣ EventBridge 트리거 생성하기&lt;/h3&gt;

&lt;p&gt;작성한 람다 함수 콘솔 화면 상단에서 &lt;strong&gt;Add trigger&lt;/strong&gt; 버튼을 눌러 다음과 같이 Rule을 생성합니다. 저는 주기를 점검하기 위해 아래와 같이 5분을 주었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/guide/eventBridgeRule.png&quot; alt=&quot;baseimage&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 &lt;a href=&quot;https://docs.aws.amazon.com/lambda/latest/dg/services-cloudwatchevents-expressions.html&quot;&gt;스케쥴 표현식 작성법&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;지금까지 Lambda 함수와 EventBrdige를 사용하여 자동으로 로그를 S3으로 백업하는 방법을 알아보았습니다.
해당 방법 외에도 로그를 이관하는 다양한 방법들이 있으므로, 더 쉽고 좋은 방법이 있다면 알려주세요!&lt;/p&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      

      
        <summary type="html">본 글은 Cloudwatch Logs groups의 데이터를 Lambda를 사용해 주기적으로 S3로 export 하는 방법을 다룹니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Using the awslogs log driver in ECS(Fargate)</title>
      <link href="https://heuristicwave.github.io/ECS_CW_Logs" rel="alternate" type="text/html" title="Using the awslogs log driver in ECS(Fargate)" />
      <published>2022-03-01T00:00:00+00:00</published>
      <updated>2022-03-01T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/ECS_CW_Logs</id>
      <content type="html" xml:base="https://heuristicwave.github.io/ECS_CW_Logs">&lt;p&gt;ECS Task의 컨테이너가 생산하는 로그들은 CloudWatch를 활용하여 수집할 수 있습니다.
Cloudwatch Logs를 운영하며 로그 적재가 제대로 되지 않거나, Timestamp가 일치하지 않거나, 지나친 지연 시간이 발생하거나, 알아보기 어려운 형태로 로그가 쌓인다면 
아래 요소들을 고민해 볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;-references&quot;&gt;📚 References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_awslogs.html&quot;&gt;Using the awslogs log driver&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;Regular expression Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;fargate에서-필요한-awslogs-로그-드라이버&quot;&gt;Fargate에서 필요한 awslogs 로그 드라이버&lt;/h2&gt;

&lt;p&gt;공식 문서에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;awslogs-region&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;awslogs-group&lt;/code&gt; 만이 필요하다고 하지만, &lt;strong&gt;Fargate&lt;/strong&gt;를 사용하는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;awslogs-stream-prefix&lt;/code&gt;이 추가적으로 필요합니다.
또한, 가시성을 확보하기 위해 CloudWatch Logs에 수집된 여러 줄의 로그를 하나의 메시지로 보기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;awslogs-multiline-pattern&lt;/code&gt;이 필수적으로 필요합니다.&lt;/p&gt;

&lt;h3 id=&quot;awslogs-multiline-pattern&quot;&gt;awslogs-multiline-pattern&lt;/h3&gt;

&lt;p&gt;공식 문서의 Note 부분을 보면 다음과 같은 메모를 확인할 수 있습니다. &lt;em&gt;(정말 공식 문서는 한 줄도 그냥 지나칠 수 없는 것 같습니다!)&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Multiline logging performs regular expression parsing and matching of all log messages.
This may have a negative impact on logging performance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;실제로 저는 정규 표현식을 간과하고 검증되지 않은 정규식들을 적용했다가 다음과 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Negative Impact&lt;/code&gt;를 만났습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;로그가 수집되기까지의 지나친 지연 시간 발생 (10분 이상)&lt;/li&gt;
  &lt;li&gt;지연시간으로 인한 Timestamp 불일치 (Ingestion time과 Event Timestamp의 과도한 오차)&lt;/li&gt;
  &lt;li&gt;1, 2번 이유로 인한 로그 미수집&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;regular-expression-lab&quot;&gt;Regular Expression Lab&lt;/h2&gt;

&lt;p&gt;지금부터 예시들을 통해, CW Logs를 운영하며 만날 수 있는 상황들을 체험해 보겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;샘플 로그를 복사하여 &lt;a href=&quot;https://regexr.com&quot;&gt;RegExr&lt;/a&gt;에서 match 여부를 테스트해 볼 수 있습니다.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;case-1️⃣&quot;&gt;Case 1️⃣&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;awslogs-multiline-pattern&lt;/code&gt;의 &lt;strong&gt;value&lt;/strong&gt;로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^INFO&lt;/code&gt;를 설정할 경우 3개의 Line 중 match 되는 라인은 몇 라인일까요?&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INFO | &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;pkg/trace/info/stats.go:104 &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;LogStats&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                &lt;span class=&quot;c&quot;&gt;# Line 1&lt;/span&gt;
INFO | &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;pkg/trace/info/stats.go:104 &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;LogStats&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                &lt;span class=&quot;c&quot;&gt;# Line 2&lt;/span&gt;
12:15:10 UTC | INFO | &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;pkg/trace/info/stats.go:104 &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;LogStats&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Line 3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;details&gt;
  &lt;summary&gt;🖍 정답 보기&lt;/summary&gt;

  &lt;blockquote&gt;
    &lt;p&gt;&lt;strong&gt;INFO&lt;/strong&gt; | (pkg/trace/info/stats.go:104 in LogStats)                # Line 1&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;^(caret) 은 전체 문자열의 시작 위치에만 일치하므로, Line 1 만이 match 됩니다.&lt;/p&gt;

&lt;/details&gt;

&lt;h3 id=&quot;case-2️⃣&quot;&gt;Case 2️⃣&lt;/h3&gt;

&lt;p&gt;다음은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시:분:초&lt;/code&gt;를 표현하는 정규 표현식 입니다. 해당 정규 표현식은 아래 3줄을 모두 Match 시킬 수 있을까요? &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0[1-9]|1[0-9]|2[0-4]):(0[1-9]|[1-5][0-9]):(0[1-9]|[1-5][0-9])&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;07:36:35 | Which line will match? Line 1
08:00:01 | I am Line 2!
08:01:00 | I am Line 3!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;details&gt;
  &lt;summary&gt;🖍 정답 보기&lt;/summary&gt;

  &lt;blockquote&gt;
    &lt;p&gt;&lt;strong&gt;07:36:35&lt;/strong&gt; | I was matched &lt;br /&gt;
08:00:01 | I was not matched! &lt;br /&gt;
08:01:00 | I was not matched! &lt;br /&gt;&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;그렇다면 왜? 첫 번째 라인만이 매칭되었을까요? &lt;strong&gt;분, 초&lt;/strong&gt;에 해당하는 표현식을 유심히 살펴보면 00분 00시는 매칭되지 않습니다.
때문에 각각 (분 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0[0-9]|[1-5][0-9])&lt;/code&gt;, 초 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0[0-9]|[1-5][0-9])&lt;/code&gt;)로 수정해야 위 3줄을 매칭 시킬 수 있습니다.&lt;/p&gt;

&lt;/details&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;other-case&quot;&gt;Other Case&lt;/h3&gt;

&lt;p&gt;위 2가지 케이스만 준비된다면 모든 로그들을 제대로 분리하여 수집할 수 있을까요?&lt;/p&gt;

&lt;details&gt;
  &lt;summary&gt;🤔 생각해보기&lt;/summary&gt;

  &lt;ul&gt;
    &lt;li&gt;Flag가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INFO&lt;/code&gt; 형식이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WARN&lt;/code&gt;이 발생할 경우&lt;/li&gt;
    &lt;li&gt;Timestamp로 매칭 작업을 하는데 한 줄에 1회 이상 Timestamp가 포함된 경우
      &lt;blockquote&gt;
        &lt;p&gt;ex) &lt;strong&gt;08:00:01&lt;/strong&gt; | It’s &lt;strong&gt;08:02:03&lt;/strong&gt; right now.&lt;/p&gt;
      &lt;/blockquote&gt;
    &lt;/li&gt;
    &lt;li&gt;Application Crash로 인한 예상치 못한 메시지가 포함될 경우&lt;/li&gt;
    &lt;li&gt;awslogs 로그 드라이버 내의 우선순위&lt;/li&gt;
  &lt;/ul&gt;

&lt;/details&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;아마도 위에 기재한 것들 외에도 더 고려 할 것들이 많을 것 같습니다.
개발이나 알고리즘 문제를 풀 때와 마찬가지로 항상 예상치 못한 실패 지점을 예상하는 습관이 필요한 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;ECS Error Handling and Troubleshooting&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./ECS_Exec&quot;&gt;Using Amazon ECS Exec for debugging&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./ECS_CW_Logs&quot;&gt;Using the awslogs log driver in ECS(Fargate)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      
        <category term="devops" />
      

      
        <summary type="html">ECS Task의 컨테이너가 생산하는 로그들은 CloudWatch를 활용하여 수집할 수 있습니다. Cloudwatch Logs를 운영하며 로그 적재가 제대로 되지 않거나, Timestamp가 일치하지 않거나, 지나친 지연 시간이 발생하거나, 알아보기 어려운 형태로 로그가 쌓인다면 아래 요소들을 고민해 볼 수 있습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Using Amazon ECS Exec for debugging</title>
      <link href="https://heuristicwave.github.io/ECS_Exec" rel="alternate" type="text/html" title="Using Amazon ECS Exec for debugging" />
      <published>2022-02-22T00:00:00+00:00</published>
      <updated>2022-02-22T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/ECS_Exec</id>
      <content type="html" xml:base="https://heuristicwave.github.io/ECS_Exec">&lt;p&gt;Docker에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec&lt;/code&gt; 명령어를 통해 실행중인 컨테이너에 접속하여 디버깅이 가능하다.
21년 3월 부터 해당 기능이 AWS의 ECS에서도 사용가능하게 되었는데, 해당 기능을 사용하며 만났던 문제들을 기록.&lt;/p&gt;

&lt;h2 id=&quot;-references&quot;&gt;📚 References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-exec.html&quot;&gt;Using Amazon ECS Exec for debugging&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/cli/latest/reference/ecs/execute-command.html&quot;&gt;AWS CLI Cmd Ref : excute-commnad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;exec-활성화&quot;&gt;Exec 활성화&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;SSM 에이전트와 SSM 서비스 간의 통신에 필요한 권한 부여&lt;/li&gt;
  &lt;li&gt;task-definition config 추가
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s2&quot;&gt;&quot;linuxParameters&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;initProcessEnabled&quot;&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;CLI로 execute-command enable 후, 점검
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aws ecs create-service &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--cluster&lt;/span&gt; cluster-name &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--task-definition&lt;/span&gt; task-definition-name &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--enable-execute-command&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--service-name&lt;/span&gt; service-name &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--desired-count&lt;/span&gt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;아래 명령어로 활성화 여부 확인. (grep option 활용, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep -F4 &quot;managedAgents&quot;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep &quot;enableExecuteCommand&quot;&lt;/code&gt;)&lt;/p&gt;
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aws ecs describe-tasks &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--cluster&lt;/span&gt; cluster-name &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--tasks&lt;/span&gt; task-id 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;활성화 상태일 때의 Snippet&lt;/p&gt;
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;tasks&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            ...
            &lt;span class=&quot;s2&quot;&gt;&quot;containers&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    ...
                    &lt;span class=&quot;s2&quot;&gt;&quot;managedAgents&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;s2&quot;&gt;&quot;lastStartedAt&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;2021-03-01T14:49:44.574000-06:00&quot;&lt;/span&gt;,
                            &lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;ExecuteCommandAgent&quot;&lt;/span&gt;,
                            &lt;span class=&quot;s2&quot;&gt;&quot;lastStatus&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;RUNNING&quot;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;,
            ...
            &lt;span class=&quot;s2&quot;&gt;&quot;enableExecuteCommand&quot;&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;,
            ...
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Running ECS Exec
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aws ecs execute-command &lt;span class=&quot;nt&quot;&gt;--cluster&lt;/span&gt; cluster-name &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--task&lt;/span&gt; task-id &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--container&lt;/span&gt; container-name &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--interactive&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--command&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/bin/sh&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;문제-해결&quot;&gt;문제 해결&lt;/h2&gt;

&lt;p&gt;Exec 명령어 이후 에러 핸들 (공식 문서들에 답이 다 있엇다 😂)&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;An error occurred &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ClusterNotFoundException&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; when calling the ExecuteCommand operation: Cluster not found.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Cluster ARN 기입 (From AWS CLI Ref : The Amazon Resource Name (ARN) or short name of the cluster from AWS CLI Ref)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SessionManagerPlugin is not found. Please refer to SessionManager Documentation here: http://docs.aws.amazon.com/console/systems-manager/session-manager-plugin-not-found
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;클라이언트 PC에 SSM Plugin 설치 (From AWS Docs : Prerequisites for using ECS Exec)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;ECS Error Handling and Troubleshooting&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./ECS_Exec&quot;&gt;Using Amazon ECS Exec for debugging&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./ECS_CW_Logs&quot;&gt;Using the awslogs log driver in ECS(Fargate)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      
        <category term="devops" />
      

      
        <summary type="html">Docker에서는 exec 명령어를 통해 실행중인 컨테이너에 접속하여 디버깅이 가능하다. 21년 3월 부터 해당 기능이 AWS의 ECS에서도 사용가능하게 되었는데, 해당 기능을 사용하며 만났던 문제들을 기록.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Create Immutable Server using AWS Image Builder &amp;amp; Auto Scaling Group</title>
      <link href="https://heuristicwave.github.io/ImageBuilder" rel="alternate" type="text/html" title="Create Immutable Server using AWS Image Builder &amp; Auto Scaling Group" />
      <published>2022-02-21T00:00:00+00:00</published>
      <updated>2022-02-21T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/ImageBuilder</id>
      <content type="html" xml:base="https://heuristicwave.github.io/ImageBuilder">&lt;p&gt;본 글은 2021년 4월 30일 &lt;a href=&quot;https://aws.amazon.com/about-aws/whats-new/2021/04/ec2-image-builder-supports-auto-scaling-launch-template/&quot;&gt;EC2 Image Builder supports Auto Scaling launch template&lt;/a&gt;
에 소개된 기능을 활용해 Image Builder로 Golden AMI를 만들고,
해당 이미지로 Auto Scaling Group의 launch template을 업데이트하는 방법을 소개합니다.&lt;/p&gt;

&lt;h1 id=&quot;intro&quot;&gt;Intro&lt;/h1&gt;

&lt;p&gt;클라우드를 다루다 보면 &lt;strong&gt;Netflix&lt;/strong&gt; 가 여러 분야에서 앞장서 있는 것을 확인할 수 있습니다.
그중에서 Immutable Server Pattern을 알리는데 기여한 2013년에 발간된 &lt;a href=&quot;https://netflixtechblog.com/ami-creation-with-aminator-98d627ca37b0&quot;&gt;AMI Creation with Aminator&lt;/a&gt;
를 꼭 한번 읽어보시기 바랍니다. 과거 넷플릭스는 AWS의 이미지 파일을 생성하기 위해 Aminator라는 도구를 사용했지만,
본 포스팅에서는 이미지 빌더로 AMI를 만들고 Auto Scaling Group에 적용시키는 방법을 배워 Immutable Server Pattern을 학습해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;immutable-server&quot;&gt;Immutable Server&lt;/h2&gt;

&lt;p&gt;Immutable Server 대한 내용은 martin fowler 블로그에 소개된 &lt;a href=&quot;https://martinfowler.com/bliki/ImmutableServer.html&quot;&gt;ImmutableServer&lt;/a&gt;
글을 보시면 굉장히 잘 설명되어 있습니다. 요약 + 그동안의 제 뇌피셜을 함께 말씀드리면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;서버를 운영하다 보면 업데이트를 비롯한 다양한 이슈들로 인해 구성요소가 자주 변하게 됩니다.
그렇게 운영하다 보면 무언가 꼬여 서버를 재 생성하는 일이 발생하는데 아래와 같은 라이프 사이클을 만나게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://martinfowler.com/bliki/images/immutableServer/PhoenixServerLifecycle.png&quot; alt=&quot;phoenixServerLifecycle&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 상황에서 구성이 다른 여러 대의 서버를 가지게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Configuration drift&lt;/code&gt;가 발생했다고 표현합니다.
또한 위 그림처럼 자꾸 새로운 이미지로 회귀하니까, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift Left&lt;/code&gt;라고도 표현하고 이를 한국어로 표현하는 말을 찾아보니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;원점 회귀&lt;/code&gt;라는 표현도 쓰입니다.&lt;/p&gt;

&lt;p&gt;구성 변경이 잦은 서버는 깨지기(fragile) 쉽고, 또 장애가 발생할 경우 재현이 어려울뿐더러 변경 시 연쇄적인 장애를 유발할 가능성이 있습니다.
이를 두고 깨지기 쉬운 눈송이 같다 하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Snowflake Server&lt;/code&gt;라 부릅니다.
이 상황을 피하기 위해, Configuration drift를 피하는 Base Image(Configuration이 발생하면 새롭게 생성)를 활용한 방법을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Phoenix Server&lt;/code&gt;
라 부릅니다. &lt;em&gt;(&lt;a href=&quot;https://martinfowler.com/bliki/PhoenixServer.html&quot;&gt;Phoenix Server&lt;/a&gt; 용어는 마틴 파울러의 동료 &lt;a href=&quot;https://twitter.com/kornys&quot;&gt;Kornelis Sietsma&lt;/a&gt; 가 제안했다 합니다.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/immutableServer.png&quot; alt=&quot;immutableServer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;피닉스 서버의 개념은 기본 이미지(Base AMI, Golden AMI)를 통해 언제나 일관성 있는 환경을 제공했고,
이러한 개념들이 자연스럽게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Immutable Server&lt;/code&gt;의 개념으로 이어졌습니다.
&lt;em&gt;(최근에는 Immutable Server를 넘어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Immutable Infrastructure&lt;/code&gt;의 개념도 있습니다!)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;이미지-빌더와-오토-스케일-그룹으로-이뮤터블-서버-구축하기&quot;&gt;이미지 빌더와 오토 스케일 그룹으로 이뮤터블 서버 구축하기&lt;/h2&gt;

&lt;p&gt;클라우드에서의 Immutable Server Pattern 검색하면 아래와 같은 좋은 예시들이 나옵니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/blogs/mt/create-immutable-servers-using-ec2-image-builder-aws-codepipeline/&quot;&gt;Create immutable servers using EC2 Image Builder and AWS CodePipeline&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloudblogs.microsoft.com/opensource/2018/05/23/immutable-infrastructure-azure-vsts-terraform-packer-ansible/&quot;&gt;Tutorial: Immutable infrastructure for Azure, using VSTS, Terraform, Packer and Ansible&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://learn.hashicorp.com/tutorials/terraform/packer&quot;&gt;Provision Infrastructure with Packer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://heuristicwave.github.io/Packer&quot;&gt;하시코프 튜토리얼을 보고 만든 필자의 블로그 🥲&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 이제부터 다룰, 이미지 빌더와 오토 스케일 그룹으로 이뮤터블 서버 패턴을 만족시킬 수 있습니다.
AWS에서 제공하는 AutoScale은 탄력적인 확장과 축소를 제공하지만 Desired Capacity 기능을 활용해 항상 동일한 서버의 수를 유지할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/background/imagebuilder.png&quot; alt=&quot;imageBuilder&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Image Builder의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Image pipelines&lt;/code&gt;를 활용해 원본 AMI로부터 원하는 형태의 Output(Custom/Golden/Base AMI)을 제작합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Distribution settings&lt;/code&gt;을 통해 lt(Launch Template)에 1번에서 생성한 AMI로 교체하여 새로운 버전을 만듭니다.&lt;/li&gt;
  &lt;li&gt;이제, 새롭게 생성되는 ASG(Auto Scaling Group)은 새롭게 버전 업된 lt를 통해 인스턴스를 생성합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;3번의 ASG의 경우, Refresh를 하기 전까지는 이전 상태의 lt를 기준으로 인스턴스가 운영되고 있습니다.
이미지 생성과 동시에 새로운 AMI로 EC2 Refresh를 할 수 있는 방법이 있지만,
새롭게 생성된 인스턴스가 운영환경에 바로 적용되는 것은 바람직하지 않으므로 해당 부분에 대한 자동화는 제외하였습니다.
만약 검증된 AMI를 생성한다면, Lambda 혹은 기타 방법 등을 통해 Refresh 하여 이미지 생성부터 배포까지 자동화할 수 있습니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;추후 다른 포스팅에서 자세히 다룰 예정이지만, 이러한 패턴은 Immutable Infrastructure의 한 요소를 이루기도 합니다.&lt;/p&gt;

&lt;h2 id=&quot;-workshop&quot;&gt;📜 Workshop&lt;/h2&gt;

&lt;h3 id=&quot;0️⃣-launch-template--auto-scaling-groups-생성&quot;&gt;0️⃣ Launch Template &amp;amp; Auto Scaling groups 생성&lt;/h3&gt;

&lt;p&gt;기존 환경에 0️⃣이 준비되어 있다면 다음 단계인 &lt;strong&gt;Distribution settings&lt;/strong&gt;으로 넘어가도 좋습니다.&lt;/p&gt;

&lt;p&gt;해당 단계는 제가 굉장히 게으른 관계로 AWS Documentation : &lt;a href=&quot;https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-asg-launch-template.html&quot;&gt;Creating an Auto Scaling group using a launch template&lt;/a&gt;
으로 대체하겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 만약 기존 환경이 Launch Template이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Launch Configurations&lt;/code&gt;으로 구성되어 있을 경우,
콘솔 화면에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Copy to launch template&lt;/code&gt; 버튼을 누르시면 손쉽게 lt로 변경 가능합니다. &lt;br /&gt;
💡 Launch Template과 Launch Configurations는 굉장히 유사하지만, Launch Template의 경우 더 다양한 기능들을 제공합니다.
특히 버전관리 기능을 통해 Rollback을 하거나, 업데이트시 ASG를 활용한 Rolling Update가 가능해 Launch Template 사용을 권장합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1️⃣-distribution-settings&quot;&gt;1️⃣ Distribution settings&lt;/h3&gt;

&lt;p&gt;EC2 Image Builder 콘솔 화면에 접속해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Distribution settings&lt;/code&gt;에서 새로운 세팅을 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/distribution.png&quot; alt=&quot;distribution&quot; /&gt;&lt;/p&gt;

&lt;p&gt;필수 항목인 이름을 작성하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Region settings&lt;/code&gt;에서 배포할 리전을 확인한 후,
하단의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Launch template configuration&lt;/code&gt;에서 Step 0️⃣에서 작성한 lt를 지정하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create settings&lt;/code&gt;로 생성합니다.&lt;/p&gt;

&lt;h3 id=&quot;2️⃣-image-pipelines&quot;&gt;2️⃣ Image pipelines&lt;/h3&gt;

&lt;h4 id=&quot;step-1&quot;&gt;Step 1&lt;/h4&gt;

&lt;p&gt;Distribution settings 작성이 완료되었다면, 콘솔에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Image pipelines&lt;/code&gt;에 접속하여 아래 정보들을 기재합니다.
아래 사진의 좌측 Step 5까지의 과정을 거치면 목표로 했던 환경이 완성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/imagepipeline.png&quot; alt=&quot;pipeline&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Build schedule&lt;/code&gt;에서는 주기적으로 파이프라인을 실행할 수 있는 방법들을 제공하는데 운영자가 원하는 방식으로 설정할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;step-2&quot;&gt;Step 2&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Choose recipe&lt;/code&gt; 단계에서는 기존에 만들어둔 &lt;strong&gt;recipe&lt;/strong&gt;가 없으므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create new recipe&lt;/code&gt;를 선택하고, &lt;strong&gt;Image type&lt;/strong&gt;으로 &lt;strong&gt;AMI&lt;/strong&gt;를 선택합니다.&lt;/p&gt;

&lt;p&gt;다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Base image&lt;/code&gt;를 고르는 단계에서는 아래 화면과 같이 &lt;strong&gt;관리형 이미지&lt;/strong&gt;를 사용하거나 기존에 작성한 &lt;strong&gt;Custom AMI ID&lt;/strong&gt;를 사용해도 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/baseimage.png&quot; alt=&quot;baseimage&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Instance configuration&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Working directory&lt;/code&gt;에서는 &lt;strong&gt;기본 값&lt;/strong&gt;으로 둬도 상관없지만
&lt;strong&gt;SSM, User data, Working directory path&lt;/strong&gt;의 필요 여부에 따라 활용하시면 됩니다.&lt;/p&gt;

&lt;p&gt;이어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Components&lt;/code&gt;에서는 Golden AMI를 구축하기 위해 선행되어야 하는 각종 Agent나 소프트웨어(Apache, dotnet etc)를 선택할 수 있습니다.
저는 편의상 CloudWatch Agent를 선택했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/components.png&quot; alt=&quot;components&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그다음 이어지는 &lt;strong&gt;Test components, Storage, Tags&lt;/strong&gt; 역시 필요 여부에 따라 활용하시면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;step-3&quot;&gt;Step 3&lt;/h4&gt;

&lt;p&gt;3단계에 진입하면 아래 사진과 같이 이미지 빌더의 인프라 Config 값들을 정의할 수 있는 공간이 나옵니다.
3번째 버튼인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create New infrastructure configuration&lt;/code&gt;으로 직접 인스턴스 유형, 네트워크, SNS topic을 설정이 가능하지만,
저는 1번 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create infrastructure configuration using service defaults&lt;/code&gt;로 기본 구성 값들을 잡아주었습니다.
(IAM Role과 SNS Topic도 자동으로 생성해 주고 굉장히 편리하네요.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/defineconfig.png&quot; alt=&quot;config&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;step-4&quot;&gt;Step 4&lt;/h4&gt;

&lt;p&gt;드디어, 이전 &lt;strong&gt;1️⃣ Distribution settings&lt;/strong&gt; 과정에서 만들어둔 &lt;strong&gt;배포 설정&lt;/strong&gt; 해당 단계에서 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/associatelt.png&quot; alt=&quot;asso&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;step-5&quot;&gt;Step 5&lt;/h4&gt;

&lt;p&gt;Review 단계까지 구성 요소들을 검토해 보고 Create pipeline을 누르고 Image pipelines 콘솔로 돌아오면 아래와 같은 화면을 만나게 됩니다.
아래 캡처화면의 경우 이미 빌드가 끝난 상태이지만, 테스트를 위해서 &lt;strong&gt;Actions - Run pipeline&lt;/strong&gt; 단계를 거치면,
ec2 콘솔에서 image build를 위한 builder 인스턴스가 생성되고 종료되는 것을 과정을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/imgconsole.png&quot; alt=&quot;console&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3️⃣-review&quot;&gt;3️⃣ Review&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;EC2 - Images - AMIs&lt;/strong&gt;에서 새롭게 생성된 AMI 확인&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;EC2 - Launch templates&lt;/strong&gt;에서 새롭게 버전이 올라간 lt 확인, 여기서 Versions 정보를 누르면 Image Builder가 생성한 Description을 확인할 수 있습니다.
&lt;img src=&quot;../../assets/built/images/post/imagebuilder/version.png&quot; alt=&quot;version&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;제대로 작동하는지 확인하기 위해 기존의 EC2 하나를 종료시키면, 저의 경우 ASG의 Desired가 2로 설정했으므로 하나의 인스턴스가 새로운 버전으로 변경됩니다.
이는 &lt;strong&gt;EC2 - Auto Scaling groups&lt;/strong&gt;에서 확인할 수 있습니다.
&lt;img src=&quot;../../assets/built/images/post/imagebuilder/asg.png&quot; alt=&quot;asg&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4️⃣-clean-up&quot;&gt;4️⃣ Clean Up&lt;/h3&gt;

&lt;p&gt;분해는 조립의 역순으로?! 2️⃣ -&amp;gt; 1️⃣ -&amp;gt; 0️⃣ 역순으로 리소스를 정리하고 3️⃣ Review 항목을 점검하여 모든 리소스가 회수되었는지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;지금까지 각종 이야기 거리들과 EC2 Image Builder를 사용하며 Immutable Server Pattern을 학습해 보았습니다.
과거 제가 Packer로 관련 환경을 구축한 적이 있는데, 역시 AWS 환경에서는 AWS의 서비스를 사용하는 게 연계도 용이하고 구축도 쉽네요.&lt;/p&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;📚 References&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;글 중간중간 하이퍼 링크로 Reference 들을 달아두었습니다.
특히, 이번 포스팅 레퍼런스들은 좋은 내용들이 많으니 원본들을 읽어보시고 당시 제가 느낀 기쁨들을 함께 느낄수 있으면 좋겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      
        <category term="devops" />
      

      
        <summary type="html">본 글은 2021년 4월 30일 EC2 Image Builder supports Auto Scaling launch template 에 소개된 기능을 활용해 Image Builder로 Golden AMI를 만들고, 해당 이미지로 Auto Scaling Group의 launch template을 업데이트하는 방법을 소개합니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Terraform Tips 2 - Data &amp;amp; Index</title>
      <link href="https://heuristicwave.github.io/TerraformTips2" rel="alternate" type="text/html" title="Terraform Tips 2 - Data &amp; Index" />
      <published>2022-01-01T00:00:00+00:00</published>
      <updated>2022-01-01T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/TerraformTips2</id>
      <content type="html" xml:base="https://heuristicwave.github.io/TerraformTips2">&lt;p&gt;Terraform 더 익숙하게 2 - Data &amp;amp; Index&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;이번 포스팅은 Tip이라 하기에는 부끄러운 사소한 지식이지만, 제가 자주 실수 하는 내용이라 글로 남기게 되었습니다. &lt;strong&gt;Terraform Data&lt;/strong&gt;를 잘 활용하면 디스크 이미지, 코드로 정의한 다양한 리소스 및 클라우드 공급자 API에서 가져온 정보들을 알 수 있습니다.
모든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Data Sources&lt;/code&gt;가 동일한 방법으로 간편하게 조회할 수 있으면 좋겠지만, 막상 사용하려고 하면 이런 저런 문제들을 만나게 됩니다.&lt;/p&gt;

&lt;p&gt;🥲 본격적으로 글을 들어가기 앞서, 이번편도 사실 제 글보다 더 좋은 학습 장소가 있어서 함께 첨부합니다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://learn.hashicorp.com/tutorials/terraform/data-sources&quot;&gt;Tutorial : Query Data Sources&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;query-az&quot;&gt;Query AZ&lt;/h2&gt;

&lt;p&gt;AWS의 리전마다 사용가능한 az가 다르기 때문에, 조금 더 유연한 코드를 작성하기 위해 다음 코드를 사용해 사용가능한 az를 검색합니다.
이후, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data.&amp;lt;NAME&amp;gt;.&amp;lt;ATTRIBUTE&amp;gt;.names&lt;/code&gt; 로 사용가능한 az 값들을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;data &lt;span class=&quot;s2&quot;&gt;&quot;aws_availability_zones&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;available&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  state &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;available&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;output &lt;span class=&quot;s2&quot;&gt;&quot;azs&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 value &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; data.aws_availability_zones.available.names
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;names&lt;/code&gt;에는 사용가능한 az가 배열 형태로 들어가 있어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;names[0]&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;names[1]&lt;/code&gt;과 같이 Index 값으로 특정 값을 지정할 수 있습니다.
그러나, 모든 data가 Index 값을 가지고 있는 것은 아닙니다.&lt;/p&gt;

&lt;h2 id=&quot;query-vpc_id&quot;&gt;Query vpc_id&lt;/h2&gt;

&lt;p&gt;다른 리소스와 AWS 솔루션들을 연계하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpc_id&lt;/code&gt; 값이 필수적으로 들어갑니다.
vpc의 id를 구하기 위해서는 다음과 같은 방법으로 id를 조회할 수 있습니다.
(tags 값을 활용해 일종의 필터링을 사용할 수도 있습니다.)&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data &lt;span class=&quot;s2&quot;&gt;&quot;aws_vpcs&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;vpcs&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    tags &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        Name &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; var.vpc_name
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

output &lt;span class=&quot;s2&quot;&gt;&quot;vpc_id&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    value &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; data.aws_vpcs.vpcs.ids
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드로 다음과 같이 Output 값을 얻을 수 있지만, 하나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;az&lt;/code&gt; 값을 얻을때와 동일한 방식으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ids[0]&lt;/code&gt; 형식으로 값을 조회하려 하면,
“This value does not have any indices.” 라는 에러 메시지와 함께 출력을 지원하지 않습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Changes to Outputs:
  + vpc_id &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
      + &lt;span class=&quot;s2&quot;&gt;&quot;vpc-0x1234567890&quot;&lt;/span&gt;,
    &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;도대체 무엇이 잘못된 것일까요? az와 동일한 방법으로 접근했지만, 왜 지원하지 않는지는 아직까지도 모르겠습니다…
누구 아시는 분이 있다면 알려주세요.&lt;/p&gt;

&lt;h3 id=&quot;count로-index-부여하기&quot;&gt;count로 index 부여하기&lt;/h3&gt;

&lt;p&gt;위 문제를 해결하기 위해서는 az를 검색할 때보다는 불편하지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt;를 사용해 해결할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;data &lt;span class=&quot;s2&quot;&gt;&quot;aws_vpc&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;target&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  count &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; length&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;data.aws_vpcs.vpcs.ids&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; tolist&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;data.aws_vpcs.vpcs.ids&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;count.index]
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# sample code using vpc_id&lt;/span&gt;
resource &lt;span class=&quot;s2&quot;&gt;&quot;aws_lb_target_group&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;sample_resource&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  count &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; length&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;data.aws_vpcs.vpcs.ids&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;# Skip Config&lt;/span&gt;
  vpc_id      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; data.aws_vpc.target[count.index].id
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aws_vpcs&lt;/code&gt;가 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aws_vpc&lt;/code&gt;를 추가하고 index 를 부여하기 위한 내장 함수들을 사용해 index를 부여합니다.
이후, 리소스에서 data 값들을 식별하기 위한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count&lt;/code&gt;를 기입하고 위와 같이 index 값으로 조회가 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;지금까지 Data를 활용해 각종 리소스들을 검색하는 방법을 알아 보았습니다.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpc_id&lt;/code&gt;도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;az&lt;/code&gt;와 같이 별도의 index 과정 없이,
간편한 조회가 가능하면 좋겠습니다. (제가 아직 방법을 모르는 것일 수도 있어요!)&lt;/p&gt;

&lt;p&gt;지금까지 테라폼 더 익숙하게 Module &amp;amp; Output 편을 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Terraform Tips&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips1&quot;&gt;Module &amp;amp; Output&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips2&quot;&gt;Data &amp;amp; Index&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="devops" />
      
        <category term="terraform" />
      

      
        <summary type="html">Terraform 더 익숙하게 2 - Data &amp;amp; Index</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">AWS CDK Library, Construct Hub</title>
      <link href="https://heuristicwave.github.io/ConstructHub" rel="alternate" type="text/html" title="AWS CDK Library, Construct Hub" />
      <published>2021-12-21T00:00:00+00:00</published>
      <updated>2021-12-21T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/ConstructHub</id>
      <content type="html" xml:base="https://heuristicwave.github.io/ConstructHub">&lt;p&gt;본 글은 지난 AWS re:Invent 2021에서 발표된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Construct Hub&lt;/code&gt;를 둘러보며 느낀 첫인상에 대한 글입니다.&lt;/p&gt;

&lt;h1 id=&quot;intro&quot;&gt;Intro&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/8_Xs8Ik0h1w?t=4666&quot;&gt;AWS re:Invent 2021, 아마존 CTO인 Dr. Werner Vogels 키노트&lt;/a&gt; 
에서 AWS CDK 라이브러리들을 활용할 수 있는 &lt;a href=&quot;https://constructs.dev/&quot;&gt;Construct Hub&lt;/a&gt; 가 발표되었습니다.
보통 AWS 리인벤트에서는 AWS 고유의 서비스들이 소개되는데요,
이번에 말씀드릴 Construct Hub는 AWS의 솔루션이 아닌 오픈 소스 커뮤니티이자,
&lt;strong&gt;CDK 라이브러리를 검색하고 공유할 수 있는 장&lt;/strong&gt;이라고 할 수 있습니다.
Construct Hub를 통해 AWS가 그리는 IaC(Infrastructure as Code)의 미래를 함께 만나보겠습니다.&lt;/p&gt;

&lt;p&gt;우선, Construct Hub를 소개하기 앞서 AWS의 IaC 도구들에 대하여 간략하게 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;️-aws-cloudformation&quot;&gt;️📂 AWS CloudFormation&lt;/h2&gt;

&lt;p&gt;2011년 AWS의 리소스를 JSON 또는 YAML 형식으로 인프라를 템플릿화 할 수 있는 CloudFormation을 발표했습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;예) AWS S3 버킷 리소스를 제어하는 CloudFormation 코드&lt;/p&gt;
  &lt;pre&gt;&lt;code class=&quot;language-YAML&quot;&gt;Resources:
  HelloBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: PublicRead
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: error.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;그러나, 인프라가 복잡해질수록 CloudFormation 코드의 길이도 길어지고 리소스 간의 관계도 파악하기 어려워 관리의 피로도가 증가하게 되었습니다.
AWS는 이러한 CloudFormation의 약점을 보완하고 개발자들이 YAML 형식으로 인프라를 정의하는 게 아니라,
&lt;strong&gt;선호하는 프로그래밍 언어로 클라우드 인프라를 정의할 수 있도록 Cloud Development Kit(CDK)&lt;/strong&gt; 를 2019년에 정식으로 출시했습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;️-aws-cloud-development-kit&quot;&gt;⌨️ AWS Cloud Development Kit&lt;/h2&gt;

&lt;p&gt;CDK는 익숙한 프로그래밍 언어를 사용해 클라우드 애플리케이션 리소스를 정의할 수 있는 오픈 소스 소프트웨어 개발 프레임워크입니다.
CDK는 어떤 방식으로, 앞서 언급된 CloudFormation의 약점들을 보완하는지 그림과 함께 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/construct/cdk.png&quot; alt=&quot;cdk&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CDK는 &lt;strong&gt;Construct&lt;/strong&gt;의 집합체라 말할 수 있습니다.
&lt;strong&gt;Construct&lt;/strong&gt;는 클라우드 서비스를 이루는 컴포넌트라 생각하셔도 좋습니다.&lt;/p&gt;

&lt;p&gt;CDK 프레임워크를 통해 개발자 혹은 클라우드 운영자는 타입스크립트, 파이썬, 닷넷, 자바 등의 익숙한 프로그래밍 언어 중
하나를 선택하여, construct 라이브러리를 사용해 프로그래밍 합니다.
하나의 Stack으로 엮어진 소스코드를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cdk synth&lt;/code&gt; 라는 명령어로 CloudFormation에서 사용되는 템플릿으로 변환하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cdk deploy&lt;/code&gt; 명령어로 인프라를 배포합니다.&lt;/p&gt;

&lt;p&gt;CDK로 작성된 인프라 코드는 프로그래밍 언어의 이점을 그대로 채택하여,
해당 언어에 익숙한 사람이라면 YAML로 작성된 CloudFormation 보다 인프라의 환경을 파악하기 쉽습니다.
실제로 올해 키노트에 언급된 &lt;a href=&quot;https://youtu.be/8_Xs8Ik0h1w?t=4872&quot;&gt;Liberty Mutual INSURANCE사의 CDK 도입 사례&lt;/a&gt; 에서
1500라인의 CloudFormation 코드를 CDK에서 단 14줄로 구현하며 CDK의 뛰어난 가시성을 알렸습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/construct/cdk2.png&quot; alt=&quot;cdk_migration&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-construct-hub&quot;&gt;🗂 Construct Hub&lt;/h2&gt;

&lt;p&gt;대망의 Construct Hub를 소개하기 위해 먼 길을 돌아왔습니다.😓
맨 처음에 Construct Hub를 오픈 소스 커뮤니티이자, CDK 라이브러리를 검색하고 공유할 수 있는 장이라고 소개한 말이 맞는지 그림과 함께 확인해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/construct/hub1.png&quot; alt=&quot;construct_hub&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://constructs.dev/&quot;&gt;Construct Hub&lt;/a&gt; 의 메인 홈페이지를 확인해 보면 CDK 라이브러리를 검색할 수 있는
‘서치 바’와 현재 ‘지원하는 언어’와 ‘서비스 프로바이더’(AWS, Datadog, Mongo DB, Aqua Security 등)가 보입니다.&lt;/p&gt;

&lt;p&gt;이 중에서도 화면 왼쪽에 위치한 다양한 CDK들의 종류에 대해 궁금증이 생기실 것 같습니다.&lt;/p&gt;

&lt;p&gt;앞서 소개한 AWS CDK는 프로그래밍 언어로 작성한 인프라 코드를 Cloudformation으로 템플릿을 생성했습니다.
이처럼 CDK가 생성하는 템플릿이 AWS Cloudformation으로 활용 가능하도록 하는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AWS CDK&lt;/code&gt;,
쿠버네티스로 활용 가능하도록 하는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CDK8s&lt;/code&gt;, 테라폼으로 활용 가능하도록 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CDKtf&lt;/code&gt;라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/construct/cdk3.png&quot; alt=&quot;cdk_type&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 현재 3가지 Type을 지원하고 있으며, 향후 다른 도구들도 지원할 가능성이 있다고 합니다.&lt;/p&gt;

&lt;p&gt;다음으로는 Construct Hub에 등록된 다양한 Construct 검색 결과입니다. 
현재는 대부분 Construct는 Hahicorp, Datadog과 같은 클라우드 서비스 Publisher 들이 참여했지만,
개인도 &lt;a href=&quot;https://aws.github.io/jsii/&quot;&gt;JSII&lt;/a&gt; (CDK가 다중 언어 라이브러리를 제공할 수 있도록 하는 기술)
기반의 construct를 만들고 aws-cdk, cdk8s, cdktf 등의 키워드와 함께 npm 레지스트리에 공개되어 있다면 약 30분 내에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Construct Hub&lt;/code&gt;에도 개시된다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/construct/hub2.png&quot; alt=&quot;construct_hub2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;화면에 보이는 특이점으로는 HashiCorp가 제공하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CDKtf&lt;/code&gt;를 통해,
다른 클라우드 서비스들과 통합하여 AWS 서비스 만이 아닌 &lt;strong&gt;모든 클라우드를 CDK로 제어 가능&lt;/strong&gt;하게 하려는 큰 그림을 그려나가고 있다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;지금까지 Construct Hub를 간단하게 살펴보며, AWS IaC 도구들의 변천사와 AWS가 그리는 IaC의 미래를 엿볼 수 있었습니다.&lt;/p&gt;

&lt;p&gt;그중에서도 흥미로웠던 요소들은 다음 2가지로 말씀드릴 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;IaC를 도입한 조직의 경우, Terraform, Ansible 등 여러 IaC 도구를 각각의 IaC 도구들의 특성에 맞게 복합적으로 운영합니다. CDK가 다방면으로 IaC 도구를 지원(AWS CDK, CDK8s, CDKtf) 하게 만들어 관리 복잡도를 줄이려는 노력이 흥미롭습니다.&lt;/li&gt;
  &lt;li&gt;CDKtf를 통해, 타 클라우드 서비스를 CDK로 제어하게 된다는 점이 흥미롭습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;사실 CDK8s, CDKtf 모두 Construct Hub가 나오기 이전부터 존재했지만, Construct Hub에 개시된 문서들을 보니 더 흥미롭게 다가옵니다.&lt;/p&gt;

&lt;p&gt;아직 세상에 알려진지 얼마 되지 않은 Construct Hub를 활용하기에는 어려움이 있지만, 누구나 Construct Hub에 기여할 수 있는 오픈소스 생태계를 구축한 만큼 빠른 성장이 기대됩니다. Construct Hub가 기여할 IaC 미래에 긍정적인 기대를 걸어봅니다.&lt;/p&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-references&quot;&gt;📚 References&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/about-aws/whats-new/2021/12/aws-construct-hub-availability/&quot;&gt;AWS Construct Hub availability&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://constructs.dev/&quot;&gt;Construct Hub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      

      
        <summary type="html">본 글은 지난 AWS re:Invent 2021에서 발표된 Construct Hub를 둘러보며 느낀 첫인상에 대한 글입니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">My first impression of AWS Karpenter</title>
      <link href="https://heuristicwave.github.io/Karpenter" rel="alternate" type="text/html" title="My first impression of AWS Karpenter" />
      <published>2021-12-20T00:00:00+00:00</published>
      <updated>2021-12-20T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/Karpenter</id>
      <content type="html" xml:base="https://heuristicwave.github.io/Karpenter">&lt;p&gt;본 글은 지난 11월 29일에 GA된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Karpenter&lt;/code&gt;를 가볍게 사용해 보며 느낀 첫인상에 대한 글입니다.&lt;/p&gt;

&lt;h1 id=&quot;intro&quot;&gt;Intro&lt;/h1&gt;

&lt;p&gt;EKS 환경에서 더 빠르고 효율적인 Kubernetes Cluster Autoscaler &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Karpenter&lt;/code&gt;가 GA 되었습니다.
오픈소스인 Karpenter는 모든 클라우드 벤더와의 통합도 목표하지만, 아직 타 클라우드와의 통합은 진행 중이라 v0.5으로 공개되었다고 합니다.
즉 GA 된 v0.5만큼은 AWS 리소스와 완벽하게 통합되었기에 이번 업데이트에 공개되었다고 할 수 있습니다.
사실 기존 EKS 환경에서도 EC2의 Autoscaling을 활용한 CA를 지원하였는데, Karpenter 출시가 어떤 영향을 미치게 될 것인지 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;kubernetes-autoscaling&quot;&gt;Kubernetes Autoscaling&lt;/h2&gt;

&lt;p&gt;쿠버네티스에서는 다음과 같은 3가지 Autoscaling 방법이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HPA(Horizontal Pod Autoscaler)&lt;/li&gt;
  &lt;li&gt;VPA(Vertical Pod Autoscaler)&lt;/li&gt;
  &lt;li&gt;CA(Cluster Autoscaler)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pod Scaling의 경우 CPU 사용량, 메트릭 등을 관찰하여 스케일링하지만, EKS 클러스터 자체의 자원이 모자라는 경우 CA를 고려해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;️-cluster-autoscaler-with-ec2-auto-scaling&quot;&gt;⚙️ Cluster Autoscaler with EC2 Auto Scaling&lt;/h2&gt;

&lt;p&gt;기존 EKS는 다음과 같이 EC2의 Autoscaler 기능을 활용해 탄력적인 환경을 구성했습니다.
&lt;img src=&quot;../../assets/built/images/post/karpenter/ec2_asg.png&quot; alt=&quot;Red Hat Reference Guide&quot; /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hpa&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpa&lt;/code&gt;가 eks에서 내에서 scaling을 진행하는 것과는 달리,
worker node를 확보하기 위해 EC2의 Auto Scaling Group을 사용하며 &lt;strong&gt;k8s와 ec2 별도의 Layer를 관리&lt;/strong&gt;해야 하는 운영 복잡도가 발생하게 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-cluster-autoscaler-with-karpenter&quot;&gt;🪓 Cluster Autoscaler with Karpenter&lt;/h2&gt;

&lt;p&gt;반면 Karpenter의 경우 k8s의 native method를 확장한 개념이기 때문에, 기존의 CA 방법과는 달리 효율적인 환경을 제공할 수 있습니다.
&lt;em&gt;(실제로 카펜터를 운영해 보면 기존의 Auto Scaling Group을 사용하지 않는 것은 아니지만,
사용자 입장에서는 고려하지 않아도 되니 k8s layer에서만 관리된다고 해도 틀린 말은 아닌 것 같습니다.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://karpenter.sh/&quot;&gt;karpenter.sh&lt;/a&gt; 의 홈 화면을 보면 간단한 동작 원리를 설명하는 그림이 있습니다.
karpenter가 unscheduled pods를 관찰하고 있다가 즉시(just-in-time) 최적화된 capacity에 pods를 배포합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/karpenter/karpenter.png&quot; alt=&quot;karpenter works&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;overprovisioning&quot;&gt;Overprovisioning&lt;/h3&gt;

&lt;p&gt;과거 EC2의 스케일링을 사용하는 CA에 대한 &lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/cluster-autoscaler.html&quot;&gt;공식 문서&lt;/a&gt;에서, 다음과 같은 고려 사항을 확인할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;노드를 확장하기 전에 노드가 확장될 때까지 기다려야 하므로 배포 대기 시간에 큰 영향을 미칩니다.
노드를 사용할 수 있게 되려면 몇 분 정도 걸릴 수 있으며, 이로 인해 포드 예약 지연 시간이 크게 늘어날 수 있습니다.
예약 대기 시간이 늘어나는 것을 감수하고 &lt;strong&gt;오버프로비저닝&lt;/strong&gt;을 사용하여 이를 완화할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;그러나 이제 karpenter를 도입한다면 &lt;strong&gt;1분 이내 최적화된 인스턴스를 바로 프로비저닝&lt;/strong&gt; 할 수 있으므로,
더 이상 미리 프로비저닝을 할 필요도 없고 워커 노드의 크기 조정도 고려하지 않아도 됩니다.&lt;/p&gt;

&lt;p&gt;어떻게 오버프로비저닝을 방지하고 컨테이너와 클라우드 환경의 이점을 더 누릴 수 있게 해주는지 제가 진행해본 테스트와 함께 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-lab&quot;&gt;👀 Lab&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;TMI : 이 글을 보는 시점에는 수정되어 있을 수도 있겠습니다만,
공식 문서에 기재된 Default Region과 Module의 azs Config 값이 통일되지 않았습니다. 수행 시, 참고하시기 바랍니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;공식 문서 &lt;a href=&quot;https://karpenter.sh/docs/getting-started-with-terraform/&quot;&gt;Terraform으로 시작하기&lt;/a&gt; 의 가이드대로
Terraform 코드를 실행시키면 EKS 내에 다음과 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;karpenter-controller&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;karpenter-webhook&lt;/code&gt; 포드가 올라온 것을 확인할 수 있습니다.
&lt;img src=&quot;../../assets/built/images/post/karpenter/initial_pods.png&quot; alt=&quot;initial_pods&quot; /&gt;
우선, Karpenter가 정말 최적화된 capacity를 제공하는지 확인하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3a&lt;/code&gt; 시리즈의 스펙을 첨부합니다.
&lt;img src=&quot;../../assets/built/images/post/karpenter/t3a.png&quot; alt=&quot;t3a_spec&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;test-1--t3amedium-인스턴스에-1cpu를-요구하는-5개의-pod-배포&quot;&gt;Test 1 : t3a.medium 인스턴스에 1cpu를 요구하는 5개의 pod 배포&lt;/h3&gt;

&lt;p&gt;문서에서 제공하는 inflate manifest를 활용해 t3a.medium 인스턴스에 1cpu를 요구하는 5개의 pod를 배포하면,
다음과 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3a.2xlarge&lt;/code&gt; 인스턴스가 즉시 프로비저닝 됩니다.
(1분 이내라고 소개되지만, 체감상 1분 보다 더 빠른 시간 안에 프로비저닝 되는 것 같습니다.)
&lt;img src=&quot;../../assets/built/images/post/karpenter/eks1.png&quot; alt=&quot;eks_dashboard&quot; /&gt;
새롭게 생성된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3a.2xlarge&lt;/code&gt; 노드를 확인하면 다음과 같이 5개의 pod가 배치된 것을 볼 수 있습니다.
&lt;img src=&quot;../../assets/built/images/post/karpenter/eks2.png&quot; alt=&quot;eks2_dashboard&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아키텍처로 보면 다음과 같습니다. 기존 t3a.medium에는 기본으로 있는 pod들 때문에 1cpu 조차 할당할 수 없습니다.
inflate는 5cpu를 요구하므로, 이를 수용할 수 있는 t3a.2xlarge 인스턴스를 프로비저닝하고 pod들을 배치시켰습니다.
요청 리소스를 기반으로 최적의 인스턴스를 할당한 것을 확인할 수 있었습니다.
&lt;img src=&quot;../../assets/built/images/post/karpenter/archi1.png&quot; alt=&quot;architecture1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;test-2--test1환경에서-05cpu를-요구하는-5개의-pod-배포&quot;&gt;Test 2 : Test1환경에서 0.5cpu를 요구하는 5개의 pod 배포&lt;/h3&gt;
&lt;p&gt;Test 1에서 &lt;strong&gt;Scalue out&lt;/strong&gt;(worker node 1대 =&amp;gt; 2대) &amp;amp; &lt;strong&gt;Scale up&lt;/strong&gt;(t3a.medium =&amp;gt; t3a.2xlarge)
를 동시에 경험해 봤다면, 이번에는 다음과 같이 필요한 리소스만 0.5 cpu로 줄여보겠습니다.
&lt;img src=&quot;../../assets/built/images/post/karpenter/vscode.png&quot; alt=&quot;vscode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기존 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3a.2xlarge&lt;/code&gt; 인스턴스가 사라지고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3a.xlarge&lt;/code&gt; 인스턴스가 즉시 프로비저닝 되었습니다.
&lt;img src=&quot;../../assets/built/images/post/karpenter/eks3.png&quot; alt=&quot;eks_dashboard3&quot; /&gt;
⬆️ a minute ago에서 ⬇️ 2minutes ago로 변하는 것을 보니 정말 1분 이내로 동작하는 것 같습니다.
&lt;img src=&quot;../../assets/built/images/post/karpenter/eks4.png&quot; alt=&quot;eks_dashboard4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;아키텍처로 보면 다음과 같습니다.
이번에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3a.medium&lt;/code&gt;에 0.5 cpu만큼의 capacity가 남아있으므로 1개의 inflate pod가 배포되었고,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3x.xlarge&lt;/code&gt; 나머지 4개의 inflate pod가 배포되었습니다.
&lt;img src=&quot;../../assets/built/images/post/karpenter/archi2.png&quot; alt=&quot;architecture2&quot; /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3a.large&lt;/code&gt;(2cpu) &amp;lt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inflate&lt;/code&gt;(0.5cpu * 4) + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kube-proxy&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aws-node&lt;/code&gt; &amp;lt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t3a.xlarge&lt;/code&gt;(4cpu)&lt;/p&gt;

&lt;p&gt;정말 빠른 시간 내에 최적의 capacity를 할당하는 모습을 보니 유연하고 높은 성능을 제공한다는 소개가 맞는 것 같습니다.&lt;/p&gt;

&lt;p&gt;저는 위 실험에서 인스턴스에 관한 별도의 CRD 값들을 지정하지 않아 karpenter가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;시리즈 인스턴스들을 프로비저닝 하였지만,
운영에서 Karpenter를 사용하기 위해서는 &lt;a href=&quot;https://karpenter.sh/docs/provisioner/&quot;&gt;Provisioner API&lt;/a&gt;를 읽고 세밀한 manifest 값들을 조정해 주어야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;
&lt;p&gt;과거 AWS의 CA는 스케일링에 걸리는 시간도 상당할뿐더러,
제한적인 스케일링으로 인해 리소스가 낭비되거나 운영환경에서 다운타임을 최소화하기 위해 오버프로비저닝 되는 경우도 많았습니다.
기존의 방법보다 더 Kubernetes native 한 karpenter를 도입한다면, 아래 그림과 같은 효과를 기대할 수 있습니다.
&lt;img src=&quot;../../assets/built/images/post/karpenter/archi3.png&quot; alt=&quot;architecture3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Karpenter의 빠른 프로비저닝과 유연한 스케일링 덕분에 클라우드를 더 클라우드답게 사용할 수 있게 된 만큼
가까운 미래에 Karpenter가 기존의 CA를 대체할 것으로 예상됩니다.
지금까지 아주 간단하게 Karpenter를 사용해 본 후기를 작성해 보았습니다.
추후, Karpenter의 자세한 동작 원리와 제약 사항 혹은 더 많은 기능들에 대하여 다뤄보겠습니다.&lt;/p&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-references&quot;&gt;📚 References&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/about-aws/whats-new/2021/11/aws-karpenter-v0-5/&quot;&gt;AWS Whats new, aws karpenter&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/blogs/aws/introducing-karpenter-an-open-source-high-performance-kubernetes-cluster-autoscaler/&quot;&gt;Introducing Karpenter&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://karpenter.sh/&quot;&gt;Karpenter Document&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      

      
        <summary type="html">본 글은 지난 11월 29일에 GA된 Karpenter를 가볍게 사용해 보며 느낀 첫인상에 대한 글입니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Terraform Tips 1 - Module &amp;amp; Output</title>
      <link href="https://heuristicwave.github.io/TerraformTips1" rel="alternate" type="text/html" title="Terraform Tips 1 - Module &amp; Output" />
      <published>2021-11-15T00:00:00+00:00</published>
      <updated>2021-11-15T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/TerraformTips1</id>
      <content type="html" xml:base="https://heuristicwave.github.io/TerraformTips1">&lt;p&gt;Terraform 더 익숙하게 1 - Module &amp;amp; Output&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Terraform Module&lt;/strong&gt;을 잘 활용하면 본인이 원하는 대로 인프라를 레고처럼 조립할 수 있습니다.
레고처럼 인프라를 조립하기 위해서는 모듈 간의 연계가 중요한데요,
이번 포스팅에서는 모듈 내에 작성된 &lt;strong&gt;Output value&lt;/strong&gt;들을 활용하는 방법을 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;해당 포스팅은 Output에 대한 이해가 있다는 가정하에 기술하였으므로, Output에 대한 설명이 필요하시면 아래 링크들을 참고해 주세요!&lt;/p&gt;

&lt;p&gt;🥲 사실, 아래 문서보다 더 잘 설명할 자신이 없어서… 언제나 가장 좋은 교재는 공식 문서입니다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.terraform.io/docs/language/values/outputs.html&quot;&gt;Terraform Docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://learn.hashicorp.com/tutorials/terraform/outputs&quot;&gt;Tutorial : Output Data from Terraform&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;output-command-option&quot;&gt;Output Command Option&lt;/h2&gt;

&lt;p&gt;Output은 terraform apply 명령어를 수행하고 난 후, 맨 마지막에 Value 들이 렌더링 되어 나옵니다.
그러나 테라폼 코드를 작성하는 중간중간 인프라의 value 값들이 필요할 때가 있습니다.&lt;/p&gt;

&lt;p&gt;그럴 때, output이 정의된 상황에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform output {label}&lt;/code&gt; 명령어로 Ouput 값을 확인합니다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-raw&lt;/code&gt; 옵션을 함께 주면 문자열 형태가 아닌 raw한 텍스트 값만을 얻을 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;terraform output &lt;span class=&quot;nt&quot;&gt;-raw&lt;/span&gt; security_group_id
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;accessing-child-module-outputs&quot;&gt;Accessing Child Module Outputs&lt;/h2&gt;

&lt;p&gt;하위 모듈의 아웃풋에 접근할 경우도 종종 있는데요, 이때는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;module.&amp;lt;모듈 명&amp;gt;.&amp;lt;Output 명&amp;gt;&lt;/code&gt; 이런 형식으로 조회가 가능합니다.
하위 모듈 출력값에 접근하는 것이, 모듈과 모듈은 연계하는 방법이기에 아래 예시에서 알아보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module &lt;span class=&quot;s2&quot;&gt;&quot;vpc&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;terraform-aws-modules/vpc/aws&quot;&lt;/span&gt;
  name   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;sample_vpc&quot;&lt;/span&gt;

  cidr &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;10.10.0.0/16&quot;&lt;/span&gt;

  azs            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;us-west-2a&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  public_subnets &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;10.10.1.0/24&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

  tags &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    Owner       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;me&quot;&lt;/span&gt;
    Environment &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;stage&quot;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같은 vpc 모듈은 security group 모듈과 거의 단짝 수준으로 함께 움직이는데요,
security group 모듈을 활용하려면 다음과 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpc_id&lt;/code&gt; 값이 필요합니다.&lt;/p&gt;

&lt;p&gt;이 경우, vpc를 먼저 생성하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vpc_id&lt;/code&gt; 값을 알아내어 사용할 수 있지만, 다음과 같은 방법으로 모듈을 연계합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module &lt;span class=&quot;s2&quot;&gt;&quot;security_group&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;terraform-aws-modules/security-group/aws&quot;&lt;/span&gt;
  name        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ssh&quot;&lt;/span&gt;
  description &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ssh from workstation&quot;&lt;/span&gt;
  vpc_id      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; module.vpc.vpc_id

  ingress_cidr_blocks &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0.0.0.0/0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
  ingress_rules       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ssh-tcp&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;find-module-output-label&quot;&gt;Find Module Output Label&lt;/h2&gt;

&lt;p&gt;방금 전, 모듈을 연계하는 방법을 배워 보았습니다. 그런데, 모듈을 연계하기 위해서는 미리 사전에 작성된 모듈의 Output Label을 알아야 합니다.&lt;/p&gt;

&lt;p&gt;우선 에디터의 Explorer 탭에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.terraform&lt;/code&gt; 폴더를 열어봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/module.png&quot; alt=&quot;module.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;apply를 적용한 &lt;em&gt;security-group, vpc&lt;/em&gt; 모듈이 내 로컬 머신에 숨어 있습니다.
해당 모듈 폴더 안에 들어가면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;outputs.tf&lt;/code&gt; 가 정의되어 있으므로 해당 파일을 참고하여 Label 값을 얻어오면 됩니다!&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;p&gt;상황 : VPC 모듈을 사용해 VPC와 서브넷을 구축한 상황에서, EFS를 각 서브넷에서 사용하려고 합니다.
EFS에서 모듈로 생성한 Subnets을 어떻게 참조할까요?&lt;/p&gt;

&lt;details&gt;
  &lt;summary&gt;🖍 정답 보기&lt;/summary&gt;

  &lt;p&gt;위에서 언급한대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modules/vpc/output.tf&lt;/code&gt; 에서 프라이빗 서브넷의 Label을 확인해보면,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private_subnets&lt;/code&gt; 이라 기재된 것을 확인할 수 있습니다. 이를 활용해 아래와 같이 모듈을 참조 할 수 있습니다.&lt;/p&gt;

  &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;resource &lt;span class=&quot;s2&quot;&gt;&quot;aws_efs_mount_target&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mount&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  count &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; length&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;module.vpc.private_subnets&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

  file_system_id &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; aws_efs_file_system.foo.id
  subnet_id      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; module.vpc.private_subnets[count.index]
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/details&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;이렇게 Module의 Output 값을 활용하는 방법을 알게 되니, 테라폼 모듈 조립에 대한 자신감이 생겼습니다. 
앞으로도 테라폼에 더 익숙하지기 위한 방법들을 시리즈로 연재할 계획인데, 언제 끝날지 모르겠습니다. 😑&lt;/p&gt;

&lt;p&gt;지금까지 테라폼 더 익숙하게 Module &amp;amp; Output 편을 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Terraform Tips&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips1&quot;&gt;Module &amp;amp; Output&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./TerraformTips2&quot;&gt;Data &amp;amp; Index&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="devops" />
      
        <category term="terraform" />
      

      
        <summary type="html">Terraform 더 익숙하게 1 - Module &amp;amp; Output</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">EC2 Clocksource</title>
      <link href="https://heuristicwave.github.io/EC2_Clocksource" rel="alternate" type="text/html" title="EC2 Clocksource" />
      <published>2021-11-08T00:00:00+00:00</published>
      <updated>2021-11-08T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/EC2_Clocksource</id>
      <content type="html" xml:base="https://heuristicwave.github.io/EC2_Clocksource">&lt;p&gt;몰라도 되지만 알면 알수록 더 신비한 EC2 🙃&lt;/p&gt;

&lt;h1 id=&quot;preview&quot;&gt;Preview&lt;/h1&gt;

&lt;p&gt;이번 포스팅에서는 &lt;a href=&quot;https://www.wellarchitectedlabs.com/performance-efficiency/100_labs/100_clock_source_performance/&quot;&gt;AWS Well-Architected Labs - Performance Efficiency&lt;/a&gt; 에 개재된 &lt;strong&gt;Calculating differences in clock source&lt;/strong&gt;
를 읽고 궁금증이 생겨 구글링을 하다 알게 된 사실들을 의식의 흐름대로 작성한 포스팅입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;performance-efficiency-summary&quot;&gt;Performance Efficiency Summary&lt;/h2&gt;

&lt;p&gt;일단 Performance Efficiency에 나오는 실험 내용을 요약하자면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;AWS의 5세대 가상머신 Nitro와 non-nitro 인스턴스 2개를 올리고 시간을 반환하는 테스트 코드를 돌려 성능 테스트를 진행합니다.
당연히 5세대 Nitro가 기존 세대보다 월등한 결과를 보여 주지만,
non-nitro 기반의 인스턴스에서 &lt;strong&gt;‘리눅스 클럭 소스를 교체하면 유의미한 성능 향상의 결과를 얻을 수 있다’&lt;/strong&gt; 라는 실험 결과를 보여줍니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Nitro 기반 인스턴스의 default clocksource : kvm-clock(권장)&lt;/p&gt;

  &lt;p&gt;Non-nitro 인스턴스의 default clocksource : xen&lt;/p&gt;

  &lt;p&gt;실험에서 교체한 Non-nitro 인스턴스의 clocksource : tsc&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;마지막으로 첨부된 &lt;a href=&quot;https://aws.amazon.com/premiumsupport/knowledge-center/manage-ec2-linux-clock-source&quot;&gt;How do I manage the clock source for EC2 instances running Linux?&lt;/a&gt;
게시물에서 클럭 소스를 교체하는 방법(&lt;em&gt;xen에서 tsc로 교체&lt;/em&gt;)을 소개하며 실험 내용을 마칩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;궁금한-건-못-참아-&quot;&gt;궁금한 건 못 참아 ❓&lt;/h2&gt;

&lt;p&gt;위에 소개한 Lab을 진행하다 보니 &lt;em&gt;‘왜 tsc로 교체하여 성능 향상 효과를 얻을 수 있는지’&lt;/em&gt; 알 수가 없었습니다.
궁금증을 해소하기 위해 구글링을 하다 보니 이해를 돕는 다음 3가지 자료를 찾을 수 있었습니다.&lt;/p&gt;

&lt;h3 id=&quot;-timestamping&quot;&gt;⏱ Timestamping&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_for_real_time/7/html/reference_guide/chap-timestamping&quot;&gt;Red Hat Reference Guide&lt;/a&gt; 에서 어느 정도 제 가려운 부분을 긁어 주었던 포스팅이 있습니다.&lt;/p&gt;

&lt;p&gt;기본적으로 멀티프로세서 시스템인 NUMA와 SMP 아키텍처에서는 여러 개의 clock source가 탑재되어 있습니다.
멀티프로세서 기반의 EC2 인스턴스에서도 아래 명령어로 사용 가능한 clocksource를 확인하면 다음과 같은 결과를 확인할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; /sys/devices/system/clocksource/clocksource0/available_clocksource
xen tsc hpet acpi_pm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Red Hat의 실험 결과에 따르면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tsc &amp;gt; hpet &amp;gt; acpi_pm&lt;/code&gt; 순으로 오버헤드가 적은데,
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tsc&lt;/code&gt;는 &lt;strong&gt;register&lt;/strong&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hpet&lt;/code&gt;은 &lt;strong&gt;memory area&lt;/strong&gt;에서 읽기 때문에 수십만 개의 타임스탬프를 지정할 때 상당한 성능 이점을 제공한다고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;️-heap-engineering-post&quot;&gt;⚙️ Heap Engineering Post&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://heap.io/blog/clocksource-aws-ec2-vdso&quot;&gt;Running a database on EC2? Your clock could be slowing you down.&lt;/a&gt; 을 보면 더 정확한 분석이 있습니다.
내용이 어려워 저는 완벽하게 이해하지 못했지만, 읽어보시면 굉장히 좋은 자료인 것 같습니다.&lt;/p&gt;

&lt;p&gt;Heap Engineering 해당 포스팅에서 &lt;strong&gt;밀당&lt;/strong&gt;을 시도하는데…
&lt;em&gt;‘tsc에서는 낮은 가능성으로 clock drift 현상이 있어 프로덕션에서는 수행하지 말라’&lt;/em&gt; 고 했다가,
실제로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clock drfit&lt;/code&gt;가 발생하지 않는다며 &lt;a href=&quot;https://www.slideshare.net/AmazonWebServices/cmp402-amazon-ec2-instances-deep-dive/24&quot;&gt;AWS가 tsc를 권장했던 슬라이드 자료&lt;/a&gt; 를 함께 보여줍니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;그냥 맘놓고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kvm-clock&lt;/code&gt;이 탑재된 인스턴스를 사용하는게 좋을 것 같습니다.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;-tudum-또-netflix&quot;&gt;🎥 Tudum~ 또! Netflix&lt;/h3&gt;

&lt;p&gt;클라우드를 공부하다 보면 Netflix 가 클라우드에 지대한 영향을 끼친 것 같다고 느낄 때가 많은데, 이번에도 그랬습니다.
AWS re:Invent 2014에서 Netflix의 &lt;a href=&quot;https://www.slideshare.net/brendangregg/performance-tuning-ec2-instances/42&quot;&gt;Senior Performance Architect, Brendan Gregg의 발표 자료&lt;/a&gt; 를 보면
&lt;strong&gt;xen에서 tsc로 교체&lt;/strong&gt;하여 &lt;strong&gt;CPU 사용량은 30%, 평균 앱 레이턴시는 43%가 줄었다&lt;/strong&gt;고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;result&quot;&gt;Result&lt;/h2&gt;

&lt;p&gt;이번에도 구글링으로 딴짓을 하다 보니 많은 사실들을 알게 되었습니다. 사실 &lt;a href=&quot;https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#AvailableInstanceTypes&quot;&gt;Current generation instances&lt;/a&gt; 를
사용하면 대부분 위에서 언급한 최적화는 T2 시리즈, Gravition 계열을 제외한 대부분의 인스턴스에서는 기본적으로 적용되어 있습니다.
그래서 포스팅의 첫 포문을 ‘몰라도 되지만 ~’이라 지었습니다.&lt;/p&gt;

&lt;p&gt;clocksource와는 별도로 이번 포스팅을 준비하다 거의 주말 하루를 소비했는데,
비교적 최근의 인스턴스가 과거 인스턴스들과 어떻게 다른지(Hypervisor, Jumbo Frame 등등)를 알 수 있었습니다.
새롭게 알게 된 사실들 역시 그냥 Nitro 기반의 Amazon Linux 2를 사용하면, 운영하는데 몰라도 지장 없이 최고의 성능을 보장받는 것 같습니다.
아직 알음알음 아는 지식이라 포스팅하기 어렵지만, 훗날 더 정확히 알게 되면 성능과 관련된 다른 튜닝 요소들도 적어보겠습니다.&lt;/p&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-포스팅과-직접적인-연관도는-떨어지지만-함께-보면-좋은-자료&quot;&gt;📚 포스팅과 직접적인 연관도는 떨어지지만 함께 보면 좋은 자료&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.brendangregg.com/blog/2017-11-29/aws-ec2-virtualization-2017.html&quot;&gt;AWS EC2 Virtualization 2017: Introducing Nitro&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/virtualization_types.html&quot;&gt;Linux AMI virtualization types&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.allthingsdistributed.com/2020/09/reinventing-virtualization-with-nitro.html&quot;&gt;Reinventing virtualization with the AWS Nitro System&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      

      
        <summary type="html">몰라도 되지만 알면 알수록 더 신비한 EC2 🙃</summary>
      

      
      
    </entry>
  
</feed>
