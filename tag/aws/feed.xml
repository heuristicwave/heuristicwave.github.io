<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator>
  <link href="https://heuristicwave.github.io/tag/aws/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://heuristicwave.github.io/" rel="alternate" type="text/html" />
  <updated>2023-03-08T15:42:09+00:00</updated>
  <id>https://heuristicwave.github.io/tag/aws/feed.xml</id>

  
  
  

  
    <title type="html">Heuristic Wave Blog | </title>
  

  
    <subtitle>Careful Writer</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">Using git submodule with AWS Code Pipeline</title>
      <link href="https://heuristicwave.github.io/submodule" rel="alternate" type="text/html" title="Using git submodule with AWS Code Pipeline" />
      <published>2023-03-07T00:00:00+00:00</published>
      <updated>2023-03-07T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/submodule</id>
      <content type="html" xml:base="https://heuristicwave.github.io/submodule">&lt;p&gt;AWS CodePipeline으로 git submodule 사용하&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;여러분이 보고계신 이 블로그(GitHub Pages 활용)는 2개의 깃헙 레포지토리를 통해 배포되고 있습니다. 첫번째 레포지토리는 원본 소스코드를 담고 있으며,
블로그 글을 작성할 때 마다 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build exec jekyll exec&lt;/code&gt;라는 명령어로 localhost에서 퇴고를 진행합니다.
이어서 원본 소스코드에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build exec jekyll build&lt;/code&gt;라는 명령어로 빌드하면 빌드 결과물이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output&lt;/code&gt; 파일에 떨어집니다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output&lt;/code&gt; 파일에는 markdown 형식으로 작성한 글들이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;html&lt;/code&gt; 파일로 빌드되어 2번째 레포지토리에 커밋됩니다.&lt;/p&gt;

&lt;p&gt;저는 이것을 자동화 하기 위해 기존에는 Travis CI를 사용하고 있었습니다.
현재 블로그로 CI/CD 파이프라인을 구축하고 약 2년간 88회의 Commit까지 잘 쓰고 있다가 어느새 다음과 같은 알람을 받아 보니, 크레딧 소진 ㅠ&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Builds have been temporarily disabled for private and public repositories due to a negative credit balance. Please go to the Plan page to replenish your credit balance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해주세요! 😃&lt;/p&gt;

&lt;hr /&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="devops" />
      
        <category term="aws" />
      

      
        <summary type="html">AWS CodePipeline으로 git submodule 사용하</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Amazon EKS Multi Cluster Upgrade with ExternalDNS</title>
      <link href="https://heuristicwave.github.io/EKS_Upgrade" rel="alternate" type="text/html" title="Amazon EKS Multi Cluster Upgrade with ExternalDNS" />
      <published>2023-02-25T00:00:00+00:00</published>
      <updated>2023-02-25T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/EKS_Upgrade</id>
      <content type="html" xml:base="https://heuristicwave.github.io/EKS_Upgrade">&lt;p&gt;ExternalDNS로 Amazon EKS 멀티 클러스터 업그레이드하기&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;Amazon EKS(이하 EKS)는 &lt;a href=&quot;https://docs.aws.amazon.com/eks/latest/userguide/kubernetes-versions.html#kubernetes-release-calendar&quot;&gt;약 3 ~ 5&lt;/a&gt; 개월마다 새로운 버전이 출시합니다.
운영 측면에서 새로운 버전 출시는 기존 EKS의 버전 업그레이드가 필요하다는 것을 의미합니다. EKS 업그레이드는 EKS 콘솔에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;지금 업데이트&lt;/code&gt; 버튼을 눌러 손쉽게 가능합니다.&lt;/p&gt;

&lt;h2 id=&quot;-single-cluster-upgrade&quot;&gt;🏠 Single Cluster Upgrade&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/eks/cluster.png&quot; alt=&quot;clusterUpdate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같은 &lt;a href=&quot;https://docs.aws.amazon.com/eks/latest/userguide/update-cluster.html&quot;&gt;EKS 클러스터 버전 업데이트&lt;/a&gt;를 싱글 클러스터 기반의 업그레이드라고 하며, 비교적 손쉽게 k8s 버전 업데이트가 가능합니다.
업데이트가 손쉬운 반면 몇 가지 제약 사항도 존재합니다. 대표적으로 아래와 같이 원하는 버전으로 바로 업데이트되는 것이 아니라 순차적 단계를 거쳐야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/eks/singleUpdate.png&quot; alt=&quot;clusterUpdate&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;️-multi-cluster-upgrade&quot;&gt;🏘️‍ Multi Cluster Upgrade&lt;/h2&gt;

&lt;p&gt;멀티 클러스터 업그레이드는 동일한 환경의 EKS를 멀티로 구성하다 보니,
싱글 클러스터와는 달리 &lt;strong&gt;원하는 버전으로 바로 생성&lt;/strong&gt;이 가능하고 만에 하나 &lt;strong&gt;롤백&lt;/strong&gt;이 필요할 경우 기존 환경으로 돌아갈 수도 있습니다.&lt;/p&gt;

&lt;p&gt;멀티 클러스터 기반의 업그레이드 방법은 여러 가지 방법으로 진행할 수 있습니다. 그중에서도 이번 포스팅에서는 &lt;a href=&quot;https://aws.amazon.com/blogs/containers/onfidos-journey-to-a-multi-cluster-amazon-eks-architecture/&quot;&gt;AWS Blog&lt;/a&gt;에 소개된 3가지 방법 중,
&lt;strong&gt;비교적 가장 수월한 방법인 첫 번째 방법으로 한정&lt;/strong&gt;해서 이야기해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/eks/multiCluster.png&quot; alt=&quot;clusterUpdate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫 번째로 소개된 Option 1의 방법은 2개의 동일한 환경에서 Amazon Route 53의 가중치 기능을 활용하여 업그레이드하는 방식입니다.&lt;/p&gt;

&lt;p&gt;방법은 간단합니다. &lt;strong&gt;싱글 클러스터&lt;/strong&gt;에서 별다른 작업을 해주지 않았다면, 아마 Route 53의 &lt;strong&gt;Routing policy&lt;/strong&gt;를 &lt;strong&gt;Simple&lt;/strong&gt;로 설정해 두었을 겁니다.
&lt;strong&gt;멀티 클러스터&lt;/strong&gt;에서는 &lt;strong&gt;Routing policy&lt;/strong&gt;를 &lt;strong&gt;Weighted&lt;/strong&gt;로 설정해 설정한 비율로 트래픽을 분배하는 원리입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/aws/defineWeighted.png&quot; alt=&quot;clusterUpdate&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 캡처와 같이 레코드를 생성할 때, 아래 3가지 요소를 주목하여 가중치 정책을 생성합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;DNS의 &lt;strong&gt;캐시를 최소화&lt;/strong&gt;하기 위해 &lt;strong&gt;TTL은 1m&lt;/strong&gt;(60 seconds)를 권장&lt;/li&gt;
  &lt;li&gt;각 다른 환경에서 &lt;strong&gt;50:50 가중치&lt;/strong&gt;를 주고 싶을 경우, &lt;strong&gt;2개의 가중치 레코드에 Weighted 값 1&lt;/strong&gt;을 부여&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Record ID&lt;/code&gt;는 레코드의 &lt;strong&gt;주석&lt;/strong&gt;과 같은 역할을 하지만 &lt;strong&gt;필수&lt;/strong&gt;로 작성해야  (이어서 이 값의 중요성을~~ 😱)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;externaldns&quot;&gt;ExternalDNS&lt;/h2&gt;

&lt;p&gt;Kubernetes는 KubeDNS를 내부 DNS 서버로 활용합니다. Route 53과 같은 다른 DNS 공급자를 사용하기 위해서는 &lt;a href=&quot;https://github.com/kubernetes-sigs/external-dns&quot;&gt;external-dns&lt;/a&gt;를 추가적으로 설치해 사용합니다.
물론 external-dns를 사용하지 않고 &lt;strong&gt;외부 DNS의 영역과 k8s의 영역을 분리하여 사용&lt;/strong&gt;할 수도 있지만, external-dns를 적용한다면 &lt;strong&gt;외부 DNS 공급자도 코드로 제어&lt;/strong&gt;할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;set-up&quot;&gt;Set up&lt;/h3&gt;

&lt;p&gt;ExternalDNS를 EKS에 설정하는 방법은 &lt;a href=&quot;https://aws.amazon.com/premiumsupport/knowledge-center/eks-set-up-externaldns/&quot;&gt;첨부 링크&lt;/a&gt;에 자세하게 설명되어 있지만, 놓치기 쉬운 2가지 부분을 언급하고 넘어가겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;externaldns-1&quot;&gt;ExternalDNS&lt;/h4&gt;

&lt;p&gt;external-dns를 최종 배포하기 전, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Deployment&lt;/code&gt;의 아래 2가지 인자를 수정해야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--domain-filter=&amp;lt;Your_R53_Domain_Name&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--txt-owner-id=&amp;lt;Your_R53_HostedZone_Id&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;🐞 이번 포스팅을 준비하며 external-dns가 간헐적으로 동작하는 경우를 목격했습니다. &lt;br /&gt;
원인은 해당 인자를 오기재했기 때문인데, 원래대로라면 동작하지 않아야 하는데 버그인 것 같습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;ingress&quot;&gt;Ingress&lt;/h4&gt;

&lt;p&gt;ExternalDNS를 제대로 설정했다면, 이어서 외부로 노출할 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ingress&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;annotations&lt;/code&gt;를 수정합니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;external-dns&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;public&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;external-dns.alpha.kubernetes.io/hostname&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myDomain.com&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;external-dns.alpha.kubernetes.io/set-identifier&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;recordID&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;external-dns.alpha.kubernetes.io/aws-weight&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;1'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Simple 라우팅 정책에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;set-identifier&lt;/code&gt;가 없어도 되지만, 이외 라우팅 정책에서는 &lt;strong&gt;필수&lt;/strong&gt;적으로 들어가야 합니다. 
직전 콘솔에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Record ID&lt;/code&gt;를 기재하지 않았을 경우 화면이 넘어가지 않지만, external-dns에서 해당 값이 빠지면 로그와 파드 상태 모두 특이점이 발견되지 않아 원인을 찾기 어려워집니다.&lt;/p&gt;

&lt;h3 id=&quot;issue&quot;&gt;Issue&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;yaml 파일에 의도를 기재하여 배포했지만, 정작 Route 53에서 레코드가 업데이트되지 않는 경우&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;구축 초기부터 가중치 정책을 적용한 멀티 클러스터를 생성한다면 해당 이슈를 만나지 않겠지만,
싱글 클러스터로 external-dns를 운영하고 있는 환경에서 멀티 클러스터를 적용하면 &lt;a href=&quot;https://github.com/kubernetes-sigs/external-dns/issues/1411&quot;&gt;해당 이슈&lt;/a&gt;를 만날 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;UPSERT is not possible, doing UPSERT will actually do a CREATE that will fail&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이를 해결하기 위해 노출하고자 하는 Ingress를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete &amp;amp; apply&lt;/code&gt; 한다면 우회가 가능하겠지만, 운영하고 있는 서비스라면 &lt;strong&gt;다운타임&lt;/strong&gt;이 발생할 것입니다.
지금으로서는 Route 53 콘솔 화면에서 수동으로 기존의 정책을 수정해 주고 후속으로 생성하는 클러스터는 코드로 제어하는 방법이 있습니다. 그러나 코드와 콘솔 2가지 채널에서 인프라를 다루는 방법은 바람직하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;해당 이슈를 해결한 직후 external-dns의 logs&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;│ &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2023-02-25T16:28:56Z&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;level&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;info &lt;span class=&quot;nv&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Applying provider record filter for domains: [myDomain.com. .myDomain.com.]&quot;&lt;/span&gt;
│ &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2023-02-25T16:28:57Z&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;level&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;info &lt;span class=&quot;nv&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Desired change: CREATE ex.myDomain.com A [Id: /hostedzone/Z0HOSTEDZONEID]&quot;&lt;/span&gt;
│ &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2023-02-25T16:28:57Z&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;level&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;info &lt;span class=&quot;nv&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Desired change: CREATE ex.myDomain.com TXT [Id: /hostedzone/Z0HOSTEDZONEID]&quot;&lt;/span&gt;
│ &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2023-02-25T16:28:57Z&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;level&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;error &lt;span class=&quot;nv&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Failure in zone myDomain.com. [Id: /hostedzone/Z0HOSTEDZONEID]&quot;&lt;/span&gt;
│ &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2023-02-25T16:28:57Z&quot;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;level&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;error &lt;span class=&quot;nv&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;InvalidChangeBatch: [RRSet with DNS name ex.myDomain.com.,
│ type TXT, SetIdentifier recordID cannot be created as a non-weighted set exists with the same name and type.]&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\t&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;status code: 400, request
│ time=&quot;&lt;/span&gt;2023-02-25T16:28:57Z&lt;span class=&quot;s2&quot;&gt;&quot; level=error msg=&quot;&lt;/span&gt;failed to submit all changes &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the following zones: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;/hostedzone/Z0HOSTEDZONEID]&lt;span class=&quot;s2&quot;&gt;&quot;

-- After changing Simple Routing policy --

│ time=&quot;&lt;/span&gt;2023-02-25T16:29:58Z&lt;span class=&quot;s2&quot;&gt;&quot; level=info msg=&quot;&lt;/span&gt;2 record&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;zone myDomain.com. &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Id: /hostedzone/Z0HOSTEDZONEID] were successfully updated&lt;span class=&quot;s2&quot;&gt;&quot;
│ time=&quot;&lt;/span&gt;2023-02-25T16:30:58Z&lt;span class=&quot;s2&quot;&gt;&quot; level=info msg=&quot;&lt;/span&gt;Applying provider record filter &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;domains: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;myDomain.com. .myDomain.com.]&lt;span class=&quot;s2&quot;&gt;&quot;
│ time=&quot;&lt;/span&gt;2023-02-25T16:30:58Z&lt;span class=&quot;s2&quot;&gt;&quot; level=info msg=&quot;&lt;/span&gt;All records are already up to &lt;span class=&quot;nb&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;검증&quot;&gt;검증&lt;/h3&gt;

&lt;p&gt;실제 1:1로 라우팅이 일어나고 있나 확인하고 싶다면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;웹&lt;/code&gt; 혹은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dig&lt;/code&gt; 명령어로 확인이 가능하지만 가장 정확한 방법은 Route 53 내 &lt;strong&gt;Test record&lt;/strong&gt;를 사용하는 것입니다.
Record 테스트를 위해 Record name을 기재하고 &lt;strong&gt;Get response&lt;/strong&gt; 버튼을 누르면 &lt;strong&gt;Response returned by Route 53&lt;/strong&gt; 화면에서 실시간으로 바뀌는 IP를 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/aws/testRecord.png&quot; alt=&quot;testRecord&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;멀티-클러스터-교체-작업&quot;&gt;멀티 클러스터 교체 작업&lt;/h4&gt;

&lt;p&gt;❗️ 기존 클러스터를 A, 업그레이드를 진행할 클러스터를 B라 가정하겠습니다.&lt;/p&gt;

&lt;p&gt;B 클러스터가 문제없다 판단되면, 다시 한번 가중치를 조절해 A 클러스터를 대체합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;가중치 변화, 1:0 🔜 1:1 🔜 0:1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;B 클러스터에서 문제가 있다 판단되면 B의 가중치를 0으로 바꾸면 롤백의 효과를 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;external-dns는 Route 53 리소스를 제어할 수 있어 편리하면서도 운영이 복잡합니다. 위에서 언급한 이슈 외에도 GitOps를 구축한 상태에서 멀티 클러스터를 운용하려면, 각 클러스터마다 다른 Repository가 필요합니다.
terraform으로 external-dns를 대체할 수도 있지만, eksctl를 사용한다면 external-dns가 도움이 되니 사용 환경에 따라 적절한 도구를 사용해야 할 것 같습니다.
모든 것을 코드로 관리하는 것은 쉽지 않네요. 🤣&lt;/p&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      
        <category term="devops" />
      
        <category term="eks" />
      

      
        <summary type="html">ExternalDNS로 Amazon EKS 멀티 클러스터 업그레이드하기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Using OpenAI API with AWS Lambda</title>
      <link href="https://heuristicwave.github.io/OpenAI_Lambda" rel="alternate" type="text/html" title="Using OpenAI API with AWS Lambda" />
      <published>2023-02-02T20:00:00+00:00</published>
      <updated>2023-02-02T20:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/OpenAI_Lambda</id>
      <content type="html" xml:base="https://heuristicwave.github.io/OpenAI_Lambda">&lt;p&gt;AWS Lambda, OpenAI API를 활용한 개인 AI 봇 만들기&lt;/p&gt;

&lt;h1 id=&quot;intro&quot;&gt;Intro&lt;/h1&gt;

&lt;p&gt;2월 2일 &lt;a href=&quot;https://www.facebook.com/groups/awskrug/&quot;&gt;AWSKRUG&lt;/a&gt;의 Slack 채널에서 ChatGPT Slack App 테스트를 시작했다는 글을 보고,
저도 메신저와 연동하여 ChatGPT를 사용해 보고 싶은 욕심이 생겼습니다. (아직, ChatGPT를 개인 봇에 적용하지는 않았습니다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/etc/awskrug.png&quot; alt=&quot;awskrug&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;🖍 해당 포스팅에서는 &lt;strong&gt;ChatGPT&lt;/strong&gt;가 아닌 GPT-3 모델 중, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text-davinci-003&lt;/code&gt; 모델을 사용했습니다.
&lt;br /&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;배경 지식 : &lt;a href=&quot;https://www.reddit.com/r/OpenAI/comments/zdrnsf/difference_between_chatgpt_and_the_new_davinci_3/&quot;&gt;Difference between ChatGPT and the new davinci 3 model?&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;이미 인터넷에 OpenAI API를 Slack과 연동하여 사용하고 있는 사례들은 많아,
제가 근무하는 회사에서 사용하고 있는 &lt;a href=&quot;https://dooray.com/main/&quot;&gt;NHN의 협업 툴 Dooray&lt;/a&gt;와 연동하기로 했습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 해당 포스팅에서는 Dooray와 AWS Lambda의 통합 방법을 다루지만,
두레이 외의 다른 메신저 도구와도 연동하는 방법이 유사하므로 해당 방법을 응용하여 활용할 수 있습니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-workflow&quot;&gt;🧭 Workflow&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/etc/dooraygpt.png&quot; alt=&quot;DoorayGPT&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위크플로우는 위와 같습니다. 사용자가 메신저에서 제공하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt; 커맨드로 질의를 하면,
해당 요청이 AWS Lambda를 통해 OpenAI의 API를 활용해 질의에 대한 대답을 받아 메신저로 전달합니다.&lt;/p&gt;

&lt;p&gt;해당 기능을 구현하기 위해서는 &lt;a href=&quot;https://platform.openai.com/account/api-keys&quot;&gt;OpenAI API keys&lt;/a&gt;와 AWS Lambda가 필요합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;작업 순서&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Lambda Layer 추가&lt;/li&gt;
  &lt;li&gt;Lambda Function 배포&lt;/li&gt;
  &lt;li&gt;Lambda Function URL 생성&lt;/li&gt;
  &lt;li&gt;Messenger 서비스와 Lambda 통합&lt;/li&gt;
  &lt;li&gt;Messenger 서비스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;POST&lt;/code&gt;에 맞춰 Lambda Function 수정&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;️-aws-lambda로-openai-api-활용하기&quot;&gt;🛠️ AWS Lambda로 OpenAI API 활용하기&lt;/h2&gt;

&lt;p&gt;OpenAI의 &lt;a href=&quot;https://platform.openai.com/docs/api-reference/introduction&quot;&gt;API REFERENCE&lt;/a&gt;를 확인하면 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Python&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node.js&lt;/code&gt;를 활용한 예시가 상세하게 나옵니다.
예시에 나오는 대로 해당 코드를 Amazon EC2를 대여하여 상시 운영 서버에서 활용해도 되지만, 메신저에 연동하여 잠깐만 활용할 예정이므로 Serverless 컴퓨팅 서비스인 Lambda를 사용하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;aws-lambda-layer-추가하기&quot;&gt;AWS Lambda Layer 추가하기&lt;/h3&gt;

&lt;p&gt;Python으로 OpenAI를 사용하기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;openai&lt;/code&gt; 파이썬 바인딩이 필요합니다.
이를 위해 람다에서 여러 함수가 공유하는 코드 및 데이터를 중앙에서 관리하는 방식인 &lt;strong&gt;Lambda Layers&lt;/strong&gt; 기능을 활용합니다.&lt;/p&gt;

&lt;p&gt;저는 OpenAI 패키지에 대한 종속성을 해결하기 위해서, &lt;a href=&quot;https://github.com/erenyasarkurt/OpenAI-AWS-Lambda-Layer&quot;&gt;OpenAI-AWS-Lambda-Layer&lt;/a&gt;를 사용했습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ 해당 레포의 &lt;a href=&quot;https://github.com/erenyasarkurt/OpenAI-AWS-Lambda-Layer/blob/main/README.md&quot;&gt;README.md&lt;/a&gt;에 기재된 대로 진행하면 curl로 OpenAI를 사용할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;우선, AWS Lambda 콘솔의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Addtional resources&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Layers&lt;/code&gt;를 클릭하여 빌드 한 zip 파일을 업로드하고 호환성(python3.8, x86_64)을 체크해 준 다음 Layer를 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/lambda/layers.png&quot; alt=&quot;Layers&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;aws-lambda-functions-배포&quot;&gt;AWS Lambda Functions 배포&lt;/h3&gt;

&lt;p&gt;이어서 람다 콘솔 화면에서 &lt;strong&gt;Create function&lt;/strong&gt;으로 함수를 생성하고 &lt;strong&gt;Add layer&lt;/strong&gt; 버튼을 눌러,
사전에 생성한 layer를 추가해 줍니다. &lt;em&gt;아래 사진과 같이 Layers 아이콘에 (1)이 추가되었습니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/lambda/code.png&quot; alt=&quot;code&quot; /&gt;&lt;/p&gt;

&lt;p&gt;⬆️ 앞서 언급한 오픈소스 파이썬 코드를 복사하고 &lt;a href=&quot;https://github.com/erenyasarkurt/OpenAI-AWS-Lambda-Layer/blob/main/lambda_function.py#L27&quot;&gt;27라인&lt;/a&gt;에 OpenAI로부터 발급받은 Key로 바꿔 적고 &lt;strong&gt;Deploy&lt;/strong&gt; 버튼을 눌러 배포합니다.&lt;/p&gt;

&lt;p&gt;⬇️ 이어서 &lt;strong&gt;Configuration&lt;/strong&gt;에서 Memory와 Timeout 값을 수정합니다.
&lt;em&gt;통상 129MB 정도의 메모리를 사용해 256MB와 OpenAPI로부터 응답이 늦어질 수 있으므로 1분이라는 넉넉한 시간을 주었습니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/lambda/config.png&quot; alt=&quot;config&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;strong&gt;Configuration&lt;/strong&gt; 탭의 &lt;strong&gt;Function URL&lt;/strong&gt;에서 URL을 생성합니다.
이때, &lt;strong&gt;Auth type&lt;/strong&gt;은 별도 인증 로직이 없는 &lt;strong&gt;NONE&lt;/strong&gt;으로 설정해 주었습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-messengerdooray와-lambda-통합하기&quot;&gt;🔄 Messenger(Dooray)와 Lambda 통합하기&lt;/h2&gt;

&lt;p&gt;저는 통합할 메신저로 두레이를 사용했습니다. 두레이에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/command&lt;/code&gt; 기능을 구현하는 방법은 다음 링크를 참고합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://helpdesk.dooray.com/share/pages/9wWo-xwiR66BO5LGshgVTg/2900080163559890590&quot;&gt;두레이 커맨드 추가하기 가이드&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Slack을 비롯한 대부분의 메신저가 외부 서버와 통합하기 위해 &lt;strong&gt;RequestUrl&lt;/strong&gt;을 요구합니다.
사전에 생성한 람다의 &lt;strong&gt;Function URL&lt;/strong&gt;을 &lt;strong&gt;RequestUrl&lt;/strong&gt;에 기재하면 통합이 완료됩니다.&lt;/p&gt;

&lt;h3 id=&quot;messengerdooray-request-형식-파악하기&quot;&gt;Messenger(Dooray) Request 형식 파악하기&lt;/h3&gt;

&lt;p&gt;이전 단계에서 테스트 없이 코드를 배포했지만, 사실 람다를 코드를 개발하고 나면 Test event를 주입하여 작성한 람다가 의도한 대로 동작하는지 확인해 봐야 합니다.
그러나 외부 서비스와 연동하여 어떠한 형식으로 Event(json)가 날라오는지 모르는 상황에서는 모니터링을 통해 파악해야 합니다.
이벤트를 1회 발생시키고 &lt;strong&gt;CloudWatch Log groups&lt;/strong&gt;에서 Event를 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/lambda/lambda_cw.png&quot; alt=&quot;lambda_cw&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두레이 유저가 생성한 command는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text&lt;/code&gt;라는 필드에 담기고 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;body&lt;/code&gt;로 감싸져 전달됩니다.
Event가 어떤 형식으로 전달되는지 알게 되었으니, 오픈소스를 해당 형식에 맞게 수정합니다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'body'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;prompt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'text'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기존 작성된 코드를 두레이 형식에 맞춰 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;text&lt;/code&gt;로 바꿔주니 아래와 같이 구현된 모습을 확인할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/etc/mybot.png&quot; alt=&quot;mybot&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;이번 포스팅에서 OpenAI API를 사용함에 있어 두레이라는 메신저와 람다를 통합하는 부분을 다뤘습니다.
하지만 Lambda와 외부 서비스가 어떻게 연동되는지 원리를 알면 어떤 서비스던지 연동이 가능합니다.&lt;/p&gt;

&lt;p&gt;이 밖에 현재 코드는 PoC 수준의 코드라 부족한 점이 많습니다.
API Key를 그대로 기재하면 &lt;strong&gt;보안 이슈&lt;/strong&gt;가 있으므로, AWS Secrets Manager를 활용한 별도의 환경 변수 처리가 필요합니다.
또한 외부 서비스에서 Function URL을 호출할 때도, 인증 작업을 추가해 줘야 합니다.
추후 ChatGPT 유료 버전이 나오면 결제하여 사용한 후기를 적기 약속하며 글을 마치겠습니다.&lt;/p&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      
        <category term="serverless" />
      

      
        <summary type="html">AWS Lambda, OpenAI API를 활용한 개인 AI 봇 만들기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">DIY Amazon EKS with eksctl</title>
      <link href="https://heuristicwave.github.io/eksctl_ppt" rel="alternate" type="text/html" title="DIY Amazon EKS with eksctl" />
      <published>2023-01-19T19:00:00+00:00</published>
      <updated>2023-01-19T19:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/eksctl_ppt</id>
      <content type="html" xml:base="https://heuristicwave.github.io/eksctl_ppt">&lt;p&gt;&lt;a href=&quot;https://www.meetup.com/awskrug/events/290666942/&quot;&gt;AWSKRUG 컨테이너 소모임🐳 - 1월 19일(목)&lt;/a&gt; 발표 자료&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;

&lt;p&gt;eksctl을 현업에서 적용하기 위해 필수적으로 필요한 최소한의 요소들을 다룹니다.&lt;/p&gt;

&lt;iframe src=&quot;https://www.slideshare.net/slideshow/embed_code/key/KnHQ8gpSIFKpbE?hostedIn=slideshare&amp;amp;page=upload&quot; width=&quot;840&quot; height=&quot;523&quot; frameborder=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;💡 SlideShare 링크를 통해 다운로드 받을 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;AWSKRUG에서는 첫 발표였는데, 부족한 발표임에도 19일 당일 소중한 시간을 내주셔서 감사합니다. 
추후, 해당 장표들을 설명하는 블로그 포스팅을 함께 개제할 예정입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;EKSCTL Tips&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./eksctl_ppt&quot;&gt;DIY Amazon EKS with eksctl (Deck)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="devops" />
      
        <category term="eks" />
      
        <category term="aws" />
      

      
        <summary type="html">AWSKRUG 컨테이너 소모임🐳 - 1월 19일(목) 발표 자료</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">ECS on EC2 Walkthrough</title>
      <link href="https://heuristicwave.github.io/ECS_Walkthrough" rel="alternate" type="text/html" title="ECS on EC2 Walkthrough" />
      <published>2022-07-03T00:00:00+00:00</published>
      <updated>2022-07-03T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/ECS_Walkthrough</id>
      <content type="html" xml:base="https://heuristicwave.github.io/ECS_Walkthrough">&lt;p&gt;EC2 기반의 ECS를 다루기 위한 사소한 지식들 톱아보기!&lt;/p&gt;

&lt;h1 id=&quot;intro&quot;&gt;Intro&lt;/h1&gt;

&lt;p&gt;당장 Amazon Elastic Container Service(이하 ECS)를 운영해야 하지만, 공식 문서를 다 읽기에는 벅차고 중요한 운영 포인트들을 빠르게 학습하기 위해 아래와 같은 요소들을 다룹니다.
&lt;em&gt;ECS 마스터&lt;/em&gt;가 될 수 있는 모든 것을 다루는 것은 아니지만, 최소한의 고민해 볼 만한 지점들을 다뤄보았습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Amazon ECS Container Agent&lt;/li&gt;
  &lt;li&gt;ECS 리소스 할당&lt;/li&gt;
  &lt;li&gt;ECS Scaling&lt;/li&gt;
  &lt;li&gt;ECS 서비스 구성&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-ecs-container-agent&quot;&gt;🕋 ECS Container Agent&lt;/h2&gt;

&lt;p&gt;EC2 기반의 ECS를 운용하기 위해서는 &lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html&quot;&gt;ECS 최적화 AMI&lt;/a&gt;를 사용해야 합니다.
일반 EC2 인스턴스로도 ECS를 운용할 수 있지만, ECS 최적화 AMI를 사용하는 것이 관리와 운용 측면에서 유리합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;예를 들어 Docker를 운영하다 보면, 미사용 상태인 컨테이너 이미지가 쌓여나가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prune&lt;/code&gt; 명령어를 통해 이미지를 정리해 주어야 합니다.
이런 상황에서 컨테이너 에이전트는 다양한 &lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/automated_image_cleanup.html#automated_image_cleanup_parameters&quot;&gt;자동화된 이미지 정리&lt;/a&gt; 옵션을 제공합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ECS-optimized AMI에는 &lt;a href=&quot;https://github.com/aws/amazon-ecs-agent&quot;&gt;Amazon ECS Container Agent&lt;/a&gt;가 기본적으로 포함되어 있습니다.
ECS 인스턴스를 부트스트랩 하는 단계에서 EC2의 user data를 사용해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/ecs/ecs.config&lt;/code&gt;에 configuration parameters을 전달합니다.&lt;/p&gt;

&lt;p&gt;아래와 같이 환경 변수를 지정하지 않아도 default 값이 지정되어 있어 운용상의 큰 문제는 없지만,
&lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-agent-config.html&quot;&gt;공식 문서&lt;/a&gt;를 확인해 필요한 configuration 들을 파악해야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;' &amp;gt;&amp;gt; /etc/ecs/ecs.config
ECS_CLUSTER=MyCluster
ECS_LOGLEVEL=debug
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;EOF
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다양한 configuration 중, 운영 환경(GPU, SPOT, 서비스 등)에 따라 필요한 Configuration 값들이 다르겠지만 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECS_RESERVED_MEMORY&lt;/code&gt;는 고려하여 지정하는 것이 좋습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 인스턴스의 모든 메모리를 테스크에 배정한다면, 테스크와 중요한 시스템 프로세스 사이에서 메모리 경합이 발생할 수 있습니다.
이를 예방하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECS_RESERVED_MEMORY&lt;/code&gt; configuration을 사용해 메모리를 예약함으로써 풀에서 할당 가능한 메모리를 제외할 수 있습니다.
필요로 하는 최소한의 요구 메모리가 정의되어 있지는 않지만, 저는 문서의 예시처럼 256MiB로 사용하고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-ecs-resource&quot;&gt;🎛 ECS Resource&lt;/h2&gt;

&lt;p&gt;ECS는 3가지 범주로 리소스를 설정할 수 있습니다.&lt;/p&gt;

&lt;p&gt;🥇 &lt;strong&gt;Container instance&lt;/strong&gt; : ECS 클러스터를 이루고 있는 EC2 인스턴스의 유형 &lt;br /&gt;
🥈 &lt;strong&gt;Task Size&lt;/strong&gt; : Task Definitions을 통해 정의하는 Size &lt;br /&gt;
🥉 &lt;strong&gt;Container Size&lt;/strong&gt; : Task Definitions의 Container 정의 부분에서 정의하는 Size &lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 ECS on EC2에서는 Task Size와 Container Size 방식 중 선택 가능하지만, Fargate 방식에서 Task Size는 필수입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;container-definitions&quot;&gt;Container definitions&lt;/h3&gt;

&lt;p&gt;Container Size의 리소스 할당 파라미터는 각각 다음과 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run&lt;/code&gt; 명령어 옵션에 매핑됩니다. &lt;br /&gt;
&lt;strong&gt;cpu&lt;/strong&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--cpu-shares&lt;/code&gt;, &lt;strong&gt;memory&lt;/strong&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--memory&lt;/code&gt;(hard) / &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--memory-reservation&lt;/code&gt;(soft)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;CPU : Unit 단위 (1,024개의 CPU 유닛은 vCPU 1개), Memory : Hard/Soft Limits&lt;/em&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hard 🆚 Soft&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Hard : 명시한 값만큼 리소스 제약이 생깁니다. 때문에 클러스터 인스턴스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker stats&lt;/code&gt; 명령어를 조회하면 LIMIT 값이 &lt;strong&gt;Hard로 명시한 값&lt;/strong&gt;으로 표시됩니다.&lt;/li&gt;
  &lt;li&gt;Soft : 명시한 값이 클러스터 인스턴스에 예약됩니다. Soft limit이므로 컨테이너 메모리 사용량이 명시한 값의 제한을 넘겨 사용 가능합니다.
Hard와 달리, 클러스터 인스턴스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker stats&lt;/code&gt; 명령어를 조회하면 LIMIT 값이 &lt;strong&gt;클러스터 인스턴스의 총 자원&lt;/strong&gt;으로 표시됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;🥇로 갈수록 더 상위 개념이며, Task Definitions에서는 🥈, 🥉을 활용해 리소스를 제어합니다.
세밀한 제어를 하고 싶다면 🥈, 🥉을 모두 사용하여 제어할 수 있으나,
🥉 사용해야 하는 특별한 이유가 없다면 🥈만을 사용해 리소스를 제어하는 것이 용이합니다.&lt;/p&gt;

&lt;h3 id=&quot;actual-available-memory&quot;&gt;Actual available memory&lt;/h3&gt;

&lt;p&gt;16GiB의 인스턴스를 프로비저닝해도 &lt;strong&gt;실제 사용 가능한 메모리(15318 MiB)&lt;/strong&gt;는 더 적습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Amazon EC2&lt;/th&gt;
      &lt;th&gt;인스턴스&lt;/th&gt;
      &lt;th&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free -m&lt;/code&gt;&lt;/th&gt;
      &lt;th&gt;Registered&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;c5.2xlarge&lt;/td&gt;
      &lt;td&gt;16384 MiB&lt;/td&gt;
      &lt;td&gt;15574 MiB&lt;/td&gt;
      &lt;td&gt;15318 MiB&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;EC2 인스턴스와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free -m&lt;/code&gt; 명령어로 확인한 차이&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ECS 플랫폼 메모리 오버헤드와 OS 커널이 차지하는 메모리로 인해 차이가 발생합니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free -m&lt;/code&gt; 명령어로 확인한 메모리와 컨테이너 인스턴스(registered)의 차이&lt;/p&gt;

&lt;p&gt;&lt;em&gt;컨테이너 에이전트를 설정할 때, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ECS_RESERVED_MEMORY=256&lt;/code&gt;으로 설정한 만큼 차이가 발생합니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-ecs-scaling&quot;&gt;🏘 ECS Scaling&lt;/h2&gt;

&lt;p&gt;ECS의 Scaling 방법은 2가지로 정의할 수 있습니다. 해당 스케일링 기법은 선택 사항이 아니라, 2가지 모두를 고려해 적용해야 합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Service에 의하여 Task가 Scaling 되는 Horizontal Autoscaling&lt;/li&gt;
  &lt;li&gt;CapacityProvider에 의하여 컨테이너 인스턴스가 Scaling 되는 Cluster Autoscaling&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;service-auto-scaling&quot;&gt;Service auto scaling&lt;/h3&gt;

&lt;p&gt;서비스 스케일링은 또다시 &lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/userguide/service-autoscaling-targettracking.html&quot;&gt;Target tracking&lt;/a&gt;과 &lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/userguide/service-autoscaling-stepscaling.html&quot;&gt;Step&lt;/a&gt; scaling으로 나뉩니다.&lt;/p&gt;

&lt;p&gt;Target tracking은 &lt;strong&gt;CPU/Memory 사용률&lt;/strong&gt; 및 &lt;strong&gt;ALB 요청 횟수&lt;/strong&gt;를 기반의 정책이 있으며, Step 방식은 &lt;strong&gt;Alarm을 활용한 Custom&lt;/strong&gt; 정책들을 작성할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 Step scaling policies의 문서 첫 문장은 다음과 같습니다. &lt;br /&gt;
Although Amazon ECS service auto scaling supports using Application Auto Scaling step scaling policies, we recommend using target tracking scaling policies instead. &lt;br /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Step scaling은 조금 더 공격적인 정책이 필요할 때 대안으로 사용하고, Service auto scaling은 복수의 조정 정책을 동시에 활용할 수 있으므로 하나의 정책에 의존하기보다는 복수의 정책을 사용해 보다 세밀한 Scaling 정책을 만드는 게 어떨까요? 🧐&lt;/p&gt;

&lt;h3 id=&quot;cluster-auto-scaling&quot;&gt;Cluster auto scaling&lt;/h3&gt;

&lt;p&gt;Service auto scaling에 컨테이너 인스턴스 내 자원을 다 할당했을 경우, CapacityProvider EC2 Auto Scaling을 활용해 클러스터 자원을 확보합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/blogs/containers/deep-dive-on-amazon-ecs-cluster-auto-scaling/&quot;&gt;AWS 블로그&lt;/a&gt;에 자세한 작동원리가 나오므로 꼭 한번 읽어보시기 바랍니다.
해당 내용을 요약하자면 &lt;strong&gt;Capacity Provider&lt;/strong&gt;를 Cluster 인프라를 관리합니다.
이를 위해 &lt;strong&gt;CapacityProviderReservation 지표&lt;/strong&gt;가 존재하고 사전에 설정한 &lt;strong&gt;Target capacity %&lt;/strong&gt;(1~100사이의 값)에 맞춰 EC2 AutoScalingGroup(ASG)에 Trigger가 작동합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CapacityProviderReservation(%) = M(현재 인스턴스+추가 요청 인스턴스)/N(현재 인스턴스) * 100(%)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;만약 Target capacity을 100으로 지정했을 때, 현재 Cluster의 Node 개수가 3이고 CapacityProviderReservation가 200이라면
CapacityProviderReservation를 목표치(Target capacity)인 100에 맞추기 위해 3개의 EC2를 Scale-out 시킵니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ To create an empty Auto Scaling group, set the desired count to zero. &lt;br /&gt; 
Capacity Provider는 &lt;strong&gt;Desired&lt;/strong&gt; 값이 &lt;strong&gt;0&lt;/strong&gt;인 ASG와 연결되어야 합니다. 또한 CapacityProvider에 의하여 관리형 조정을 enable 한 상태에서,
ASG를 &lt;strong&gt;수동&lt;/strong&gt;으로 수정한다면 CapacityProviderReservation 계산에 영향을 미칠 수 있으므로 &lt;strong&gt;지양&lt;/strong&gt;해야 합니다. 
&lt;br /&gt;&lt;br /&gt;
🚫️ DO NOT EDIT OR DELETE &lt;br /&gt;
해당 메시지는 Service &amp;amp; Cluster Scaling이 CloudWatch에 자동으로 생성한 TargetTracking의 주석 내용입니다.
관리형 정책의 기능을 활용 시, 조금 더 세밀한 Scaling 필요하다면 알람 Trigger의 빈도가 아닌 다른 방안을 고민하도록 합니다!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-ecs-service-configuration&quot;&gt;🧮 ECS Service Configuration&lt;/h2&gt;

&lt;h3 id=&quot;deployment-configuration&quot;&gt;Deployment Configuration&lt;/h3&gt;

&lt;p&gt;ECS 서비스에서 &lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_DeploymentConfiguration.html&quot;&gt;배포와 관련된 설정&lt;/a&gt;을 보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;maximumPercent&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minimumHealthyPercent&lt;/code&gt;가 있습니다.
비슷하면서도 헷갈리기 쉬운 2개의 설정값 개념은 손에 잡힐듯하면서도 쉽게 잡히지 않는 것 같아, 예시 상황을 적어보았습니다.😂&lt;/p&gt;

&lt;p&gt;&lt;em&gt;해당 개념이 조금 더 와닿을 수 있도록, 공식 문서를 읽어보시고 아래 상황이 어떨지 예상해 보세요!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;🧑🏻‍💻는 ECS &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;maximumPercent&lt;/code&gt;가 200%, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minimumHealthyPercent&lt;/code&gt;가 100%로 설정되어 있으며, Rolling update 방식을 사용하고 있다.
현재 ver01을 운영하는 🧑🏻‍💻는 실수로 오류를 포함한 ver02를 배포했다. 기존 Task 4개일 때, 어떤 상황이 벌어지는가?&lt;/p&gt;

&lt;details&gt;
  &lt;summary&gt;🖍 정답 보기&lt;/summary&gt;

  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minimumHealthyPercent&lt;/code&gt;가 100%이기 때문에 ver02에 프로비저닝되고 정상 상태로 확인될 때까지 ver01은 중단되지 않습니다.
ver02는 &lt;strong&gt;running&lt;/strong&gt; 상태로 진입하지 못해 &lt;strong&gt;provisioning-pending-stopped&lt;/strong&gt; 단계를 반복합니다.
이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;maximumPercent&lt;/code&gt;가 200%임에 따라 ver02 Task는 4개와 ver01 Task 4개(합, 최대 8개)의 Task가 동시에 올라올 수 있습니다.&lt;/p&gt;

&lt;/details&gt;

&lt;h3 id=&quot;task-placement&quot;&gt;Task Placement&lt;/h3&gt;

&lt;p&gt;ECS의 서비스가 컨테이너 인스턴스에 Task를 배치하는 전략은 아래와 같이 3가지 분류됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binpack&lt;/code&gt;: CPU 또는 메모리를 최소화하기 위해 유휴 자원을 고려한 배치&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;random&lt;/code&gt; : 무작위 배치&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spread&lt;/code&gt; : ami-id, availability-zone, instance-type, os-type 등을 고려한 배치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 3가지 전략은 단독 혹은 복수로 선택되어 사용될 수 있으며, 가용성을 확보하기 위해 AZ를 고려하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AZ + binpack&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AZ + spread&lt;/code&gt;와 같이 사용되기도 합니다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;쿠버네티스를 공부해 보신 분이라면, 해당 전략은 마치 k8s의 nodeSelector와 비슷하게 동작합니다.&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;🔊 CapacityProviderReservation에 영향을 미치는 배포 설정과 배치 전략 &lt;br /&gt;
ECS 서비스 설정에서 언급한 배포 설정과 배치 전략은 가용성 문제와 직결되고 이는 비용 문제로도 이어집니다.
앞서 언급 한 CapacityProviderReservation 계산에 활용되는 M 값에 배포 설정과 배치 전략이 영향을 미친다는 점을 유의하세요!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;이번 포스팅을 통해 ECS와 관련된 내용을 정리하다 보니, AWS 내의 다른 오케스트레이션 서비스인 EKS의 운용 전략과 무척이나 비슷하다는 느낌을 지울 수 없었습니다.
쿠버네티스의 HPA 최적화, Pod 배치 및 리소스 할당 전략과 같은 포인트들은 운영을 하며 지속적으로 관리하는 관리 대상인 만큼,
위에 언급된 ECS의 운영 포인트들도 &lt;strong&gt;서비스를 배포한 이후에도 지속적으로 관심&lt;/strong&gt;을 가져야 하는 포인트임을 강조하며 마칩니다.&lt;/p&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      

      
        <summary type="html">EC2 기반의 ECS를 다루기 위한 사소한 지식들 톱아보기!</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Export cloudwatch log data to Amazon S3 using lambda</title>
      <link href="https://heuristicwave.github.io/Export_data_to_S3_Lambda" rel="alternate" type="text/html" title="Export cloudwatch log data to Amazon S3 using lambda" />
      <published>2022-04-07T00:00:00+00:00</published>
      <updated>2022-04-07T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/Export_data_to_S3_Lambda</id>
      <content type="html" xml:base="https://heuristicwave.github.io/Export_data_to_S3_Lambda">&lt;p&gt;본 글은 Cloudwatch Logs groups의 데이터를 Lambda를 사용해 주기적으로 S3로 export 하는 방법을 다룹니다.&lt;/p&gt;

&lt;h1 id=&quot;intro&quot;&gt;Intro&lt;/h1&gt;

&lt;p&gt;글을 시작하기 앞서, &lt;a href=&quot;https://noob2geek.in/2021/06/18/export-aws-cloudwatch-logs-to-s3-using-lambda-functions-in-node-js/&quot;&gt;Shraddha Paghdar - Export AWS CloudWatch logs to S3 using lambda functions in Node.js&lt;/a&gt;
를 참고하여 해당 글을 작성했음을 알립니다. 본격적으로 방법을 소개하기 앞서, Cloudwatch Logs groups의 데이터를 Lambda를 사용해 주기적으로 S3로 export 하기 위한 플로우는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/background/exportLambda.png&quot; alt=&quot;imageBuilder&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Amazon EventBridge에 정의한 Rule에 의해 Lambda를 호출합니다.&lt;/li&gt;
  &lt;li&gt;이후 람다가 지정한 CloudWatch의 Logs에 적재된 데이터를 찾습니다.&lt;/li&gt;
  &lt;li&gt;2번에 연속되어 이관될 대상의 로그들이 S3로 이관됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;-workshop&quot;&gt;📜 Workshop&lt;/h2&gt;

&lt;h3 id=&quot;1️⃣-log를-담을-bucket-및-정책-생성하기&quot;&gt;1️⃣ Log를 담을 Bucket 및 정책 생성하기&lt;/h3&gt;

&lt;p&gt;Amazon S3 콘솔 화면에 접속해 Log들이 담길 Bucket을 생성하고 이어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Permissions&lt;/code&gt;에서 S3 버킷에 대한 권한을 설정합니다.
해당 방법은 &lt;a href=&quot;https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/S3ExportTasksConsole.html&quot;&gt;공식 문서, 1단계와 3단계&lt;/a&gt;에 자세히 설명되어 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 공식 문서 3단계에서 기재된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;random-string&lt;/code&gt;은 필요에 의한 경우 사용하세요. 해당 글에서는 편의상 생략하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;2️⃣-lambda-생성하기&quot;&gt;2️⃣ Lambda 생성하기&lt;/h3&gt;

&lt;h4 id=&quot;step-1--lambda가-사용하는-iam-role--policy-생성&quot;&gt;Step 1 : Lambda가 사용하는 IAM Role &amp;amp; Policy 생성&lt;/h4&gt;

&lt;p&gt;Lambda가 Log를 Export 할 수 있도록 다음 정책을 생성합니다.
IAM에서 Create policy를 선택하고 아래 JSON을 복사하여 붙여 넣고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cloudwatch_export_task&lt;/code&gt;라는 이름으로 정책을 생성합니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;Version&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;2012-10-17&quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&quot;Statement&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;s2&quot;&gt;&quot;Effect&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;Allow&quot;&lt;/span&gt;,
            &lt;span class=&quot;s2&quot;&gt;&quot;Action&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;logs:CreateExportTask&quot;&lt;/span&gt;,
            &lt;span class=&quot;s2&quot;&gt;&quot;Resource&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;arn:aws:logs:{Region}:{AccountNumber}:*&quot;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Lambda에 권한을 부여해 주기 위해서 IAM &amp;gt; Roles &amp;gt; Create Role을 선택합니다.
Use case로 Lambda를 선택하고 앞서 생성한 정책을 부여한 뒤, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;export_S3_lambda&lt;/code&gt;라는 이름으로 Role을 생성합니다.&lt;/p&gt;

&lt;h4 id=&quot;step-2--코드-작성&quot;&gt;Step 2 : 코드 작성&lt;/h4&gt;

&lt;p&gt;Lambda 콘솔 화면에서 아래와 같이 빈칸을 채우고, Step 1에서 만들어둔 role을 부여해 람다 함수를 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/guide/exportLambda.png&quot; alt=&quot;baseimage&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 만약, Export 역할을 수행하는 &lt;strong&gt;람다 함수가 생성하는 로그&lt;/strong&gt;를 수집하고 싶을 경우에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create a new role with basic Lambda permissions&lt;/code&gt;을
선택하고 Console에 의해 자동적으로 생성되는 Role에 Step 1에서 만든 정책을 부여하면 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이어서 아래 코드를 복사하여 상황에 맞는 인자 값을 넣어주고 Deploy 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Parameter&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;region : 로그 그룹과 대상 버킷은 동일 리전에 위치&lt;/li&gt;
  &lt;li&gt;destination : 로그가 이관되는 대상 버킷&lt;/li&gt;
  &lt;li&gt;logGroupName : Cloudwatch Log group 이름&lt;/li&gt;
  &lt;li&gt;destinationPrefix : 1️⃣ 에서 언급한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;random-string&lt;/code&gt; 값&lt;/li&gt;
  &lt;li&gt;from/to : Lambda 함수가 호출 되는 시점을 기준으로, from/to 기간의 로그 그룹들을 export&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AWS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;aws-sdk&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cloudconfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;2014-03-28&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;region&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;region&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cloudwatchlogs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AWS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;CloudWatchLogs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cloudconfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;destination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;bucket-name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;logGroupName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;log-groups-name&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;destinationPrefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;86400&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cloudwatchlogs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;createExportTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;statusCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;statusCode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;501&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 테스트 버튼을 눌러 결과값을 보면 taskId 값이 생성되고 S3에 로그가 이관된 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;3️⃣-eventbridge-트리거-생성하기&quot;&gt;3️⃣ EventBridge 트리거 생성하기&lt;/h3&gt;

&lt;p&gt;작성한 람다 함수 콘솔 화면 상단에서 &lt;strong&gt;Add trigger&lt;/strong&gt; 버튼을 눌러 다음과 같이 Rule을 생성합니다. 저는 주기를 점검하기 위해 아래와 같이 5분을 주었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/guide/eventBridgeRule.png&quot; alt=&quot;baseimage&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 &lt;a href=&quot;https://docs.aws.amazon.com/lambda/latest/dg/services-cloudwatchevents-expressions.html&quot;&gt;스케쥴 표현식 작성법&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;지금까지 Lambda 함수와 EventBrdige를 사용하여 자동으로 로그를 S3으로 백업하는 방법을 알아보았습니다.
해당 방법 외에도 로그를 이관하는 다양한 방법들이 있으므로, 더 쉽고 좋은 방법이 있다면 알려주세요!&lt;/p&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      

      
        <summary type="html">본 글은 Cloudwatch Logs groups의 데이터를 Lambda를 사용해 주기적으로 S3로 export 하는 방법을 다룹니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Using the awslogs log driver in ECS(Fargate)</title>
      <link href="https://heuristicwave.github.io/ECS_CW_Logs" rel="alternate" type="text/html" title="Using the awslogs log driver in ECS(Fargate)" />
      <published>2022-03-01T00:00:00+00:00</published>
      <updated>2022-03-01T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/ECS_CW_Logs</id>
      <content type="html" xml:base="https://heuristicwave.github.io/ECS_CW_Logs">&lt;p&gt;ECS Task의 컨테이너가 생산하는 로그들은 CloudWatch를 활용하여 수집할 수 있습니다.
Cloudwatch Logs를 운영하며 로그 적재가 제대로 되지 않거나, Timestamp가 일치하지 않거나, 지나친 지연 시간이 발생하거나, 알아보기 어려운 형태로 로그가 쌓인다면 
아래 요소들을 고민해 볼 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;-references&quot;&gt;📚 References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using_awslogs.html&quot;&gt;Using the awslogs log driver&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;Regular expression Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;fargate에서-필요한-awslogs-로그-드라이버&quot;&gt;Fargate에서 필요한 awslogs 로그 드라이버&lt;/h2&gt;

&lt;p&gt;공식 문서에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;awslogs-region&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;awslogs-group&lt;/code&gt; 만이 필요하다고 하지만, &lt;strong&gt;Fargate&lt;/strong&gt;를 사용하는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;awslogs-stream-prefix&lt;/code&gt;이 추가적으로 필요합니다.
또한, 가시성을 확보하기 위해 CloudWatch Logs에 수집된 여러 줄의 로그를 하나의 메시지로 보기 위해서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;awslogs-multiline-pattern&lt;/code&gt;이 필수적으로 필요합니다.&lt;/p&gt;

&lt;h3 id=&quot;awslogs-multiline-pattern&quot;&gt;awslogs-multiline-pattern&lt;/h3&gt;

&lt;p&gt;공식 문서의 Note 부분을 보면 다음과 같은 메모를 확인할 수 있습니다. &lt;em&gt;(정말 공식 문서는 한 줄도 그냥 지나칠 수 없는 것 같습니다!)&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Multiline logging performs regular expression parsing and matching of all log messages.
This may have a negative impact on logging performance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;실제로 저는 정규 표현식을 간과하고 검증되지 않은 정규식들을 적용했다가 다음과 같은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Negative Impact&lt;/code&gt;를 만났습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;로그가 수집되기까지의 지나친 지연 시간 발생 (10분 이상)&lt;/li&gt;
  &lt;li&gt;지연시간으로 인한 Timestamp 불일치 (Ingestion time과 Event Timestamp의 과도한 오차)&lt;/li&gt;
  &lt;li&gt;1, 2번 이유로 인한 로그 미수집&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;regular-expression-lab&quot;&gt;Regular Expression Lab&lt;/h2&gt;

&lt;p&gt;지금부터 예시들을 통해, CW Logs를 운영하며 만날 수 있는 상황들을 체험해 보겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;샘플 로그를 복사하여 &lt;a href=&quot;https://regexr.com&quot;&gt;RegExr&lt;/a&gt;에서 match 여부를 테스트해 볼 수 있습니다.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;case-1️⃣&quot;&gt;Case 1️⃣&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;awslogs-multiline-pattern&lt;/code&gt;의 &lt;strong&gt;value&lt;/strong&gt;로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^INFO&lt;/code&gt;를 설정할 경우 3개의 Line 중 match 되는 라인은 몇 라인일까요?&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INFO | &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;pkg/trace/info/stats.go:104 &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;LogStats&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                &lt;span class=&quot;c&quot;&gt;# Line 1&lt;/span&gt;
INFO | &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;pkg/trace/info/stats.go:104 &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;LogStats&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;                &lt;span class=&quot;c&quot;&gt;# Line 2&lt;/span&gt;
12:15:10 UTC | INFO | &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;pkg/trace/info/stats.go:104 &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;LogStats&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# Line 3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;details&gt;
  &lt;summary&gt;🖍 정답 보기&lt;/summary&gt;

  &lt;blockquote&gt;
    &lt;p&gt;&lt;strong&gt;INFO&lt;/strong&gt; | (pkg/trace/info/stats.go:104 in LogStats)                # Line 1&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;^(caret) 은 전체 문자열의 시작 위치에만 일치하므로, Line 1 만이 match 됩니다.&lt;/p&gt;

&lt;/details&gt;

&lt;h3 id=&quot;case-2️⃣&quot;&gt;Case 2️⃣&lt;/h3&gt;

&lt;p&gt;다음은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시:분:초&lt;/code&gt;를 표현하는 정규 표현식 입니다. 해당 정규 표현식은 아래 3줄을 모두 Match 시킬 수 있을까요? &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0[1-9]|1[0-9]|2[0-4]):(0[1-9]|[1-5][0-9]):(0[1-9]|[1-5][0-9])&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;07:36:35 | Which line will match? Line 1
08:00:01 | I am Line 2!
08:01:00 | I am Line 3!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;details&gt;
  &lt;summary&gt;🖍 정답 보기&lt;/summary&gt;

  &lt;blockquote&gt;
    &lt;p&gt;&lt;strong&gt;07:36:35&lt;/strong&gt; | I was matched &lt;br /&gt;
08:00:01 | I was not matched! &lt;br /&gt;
08:01:00 | I was not matched! &lt;br /&gt;&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;그렇다면 왜? 첫 번째 라인만이 매칭되었을까요? &lt;strong&gt;분, 초&lt;/strong&gt;에 해당하는 표현식을 유심히 살펴보면 00분 00시는 매칭되지 않습니다.
때문에 각각 (분 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0[0-9]|[1-5][0-9])&lt;/code&gt;, 초 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0[0-9]|[1-5][0-9])&lt;/code&gt;)로 수정해야 위 3줄을 매칭 시킬 수 있습니다.&lt;/p&gt;

&lt;/details&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;other-case&quot;&gt;Other Case&lt;/h3&gt;

&lt;p&gt;위 2가지 케이스만 준비된다면 모든 로그들을 제대로 분리하여 수집할 수 있을까요?&lt;/p&gt;

&lt;details&gt;
  &lt;summary&gt;🤔 생각해보기&lt;/summary&gt;

  &lt;ul&gt;
    &lt;li&gt;Flag가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INFO&lt;/code&gt; 형식이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WARN&lt;/code&gt;이 발생할 경우&lt;/li&gt;
    &lt;li&gt;Timestamp로 매칭 작업을 하는데 한 줄에 1회 이상 Timestamp가 포함된 경우
      &lt;blockquote&gt;
        &lt;p&gt;ex) &lt;strong&gt;08:00:01&lt;/strong&gt; | It’s &lt;strong&gt;08:02:03&lt;/strong&gt; right now.&lt;/p&gt;
      &lt;/blockquote&gt;
    &lt;/li&gt;
    &lt;li&gt;Application Crash로 인한 예상치 못한 메시지가 포함될 경우&lt;/li&gt;
    &lt;li&gt;awslogs 로그 드라이버 내의 우선순위&lt;/li&gt;
  &lt;/ul&gt;

&lt;/details&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;아마도 위에 기재한 것들 외에도 더 고려 할 것들이 많을 것 같습니다.
개발이나 알고리즘 문제를 풀 때와 마찬가지로 항상 예상치 못한 실패 지점을 예상하는 습관이 필요한 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;ECS Error Handling and Troubleshooting&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./ECS_Exec&quot;&gt;Using Amazon ECS Exec for debugging&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./ECS_CW_Logs&quot;&gt;Using the awslogs log driver in ECS(Fargate)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      
        <category term="devops" />
      

      
        <summary type="html">ECS Task의 컨테이너가 생산하는 로그들은 CloudWatch를 활용하여 수집할 수 있습니다. Cloudwatch Logs를 운영하며 로그 적재가 제대로 되지 않거나, Timestamp가 일치하지 않거나, 지나친 지연 시간이 발생하거나, 알아보기 어려운 형태로 로그가 쌓인다면 아래 요소들을 고민해 볼 수 있습니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Using Amazon ECS Exec for debugging</title>
      <link href="https://heuristicwave.github.io/ECS_Exec" rel="alternate" type="text/html" title="Using Amazon ECS Exec for debugging" />
      <published>2022-02-22T00:00:00+00:00</published>
      <updated>2022-02-22T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/ECS_Exec</id>
      <content type="html" xml:base="https://heuristicwave.github.io/ECS_Exec">&lt;p&gt;Docker에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exec&lt;/code&gt; 명령어를 통해 실행중인 컨테이너에 접속하여 디버깅이 가능하다.
21년 3월 부터 해당 기능이 AWS의 ECS에서도 사용가능하게 되었는데, 해당 기능을 사용하며 만났던 문제들을 기록.&lt;/p&gt;

&lt;h2 id=&quot;-references&quot;&gt;📚 References&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-exec.html&quot;&gt;Using Amazon ECS Exec for debugging&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/cli/latest/reference/ecs/execute-command.html&quot;&gt;AWS CLI Cmd Ref : excute-commnad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;exec-활성화&quot;&gt;Exec 활성화&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;SSM 에이전트와 SSM 서비스 간의 통신에 필요한 권한 부여&lt;/li&gt;
  &lt;li&gt;task-definition config 추가
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s2&quot;&gt;&quot;linuxParameters&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;initProcessEnabled&quot;&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;CLI로 execute-command enable 후, 점검
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aws ecs create-service &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--cluster&lt;/span&gt; cluster-name &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--task-definition&lt;/span&gt; task-definition-name &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--enable-execute-command&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--service-name&lt;/span&gt; service-name &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--desired-count&lt;/span&gt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;아래 명령어로 활성화 여부 확인. (grep option 활용, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep -F4 &quot;managedAgents&quot;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep &quot;enableExecuteCommand&quot;&lt;/code&gt;)&lt;/p&gt;
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aws ecs describe-tasks &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--cluster&lt;/span&gt; cluster-name &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--tasks&lt;/span&gt; task-id 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;활성화 상태일 때의 Snippet&lt;/p&gt;
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;tasks&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            ...
            &lt;span class=&quot;s2&quot;&gt;&quot;containers&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    ...
                    &lt;span class=&quot;s2&quot;&gt;&quot;managedAgents&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;s2&quot;&gt;&quot;lastStartedAt&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;2021-03-01T14:49:44.574000-06:00&quot;&lt;/span&gt;,
                            &lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;ExecuteCommandAgent&quot;&lt;/span&gt;,
                            &lt;span class=&quot;s2&quot;&gt;&quot;lastStatus&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;RUNNING&quot;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;,
            ...
            &lt;span class=&quot;s2&quot;&gt;&quot;enableExecuteCommand&quot;&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;,
            ...
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Running ECS Exec
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aws ecs execute-command &lt;span class=&quot;nt&quot;&gt;--cluster&lt;/span&gt; cluster-name &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--task&lt;/span&gt; task-id &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--container&lt;/span&gt; container-name &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--interactive&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;--command&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/bin/sh&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;문제-해결&quot;&gt;문제 해결&lt;/h2&gt;

&lt;p&gt;Exec 명령어 이후 에러 핸들 (공식 문서들에 답이 다 있엇다 😂)&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;An error occurred &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ClusterNotFoundException&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; when calling the ExecuteCommand operation: Cluster not found.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Cluster ARN 기입 (From AWS CLI Ref : The Amazon Resource Name (ARN) or short name of the cluster from AWS CLI Ref)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SessionManagerPlugin is not found. Please refer to SessionManager Documentation here: http://docs.aws.amazon.com/console/systems-manager/session-manager-plugin-not-found
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;클라이언트 PC에 SSM Plugin 설치 (From AWS Docs : Prerequisites for using ECS Exec)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;ECS Error Handling and Troubleshooting&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./ECS_Exec&quot;&gt;Using Amazon ECS Exec for debugging&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./ECS_CW_Logs&quot;&gt;Using the awslogs log driver in ECS(Fargate)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      
        <category term="devops" />
      

      
        <summary type="html">Docker에서는 exec 명령어를 통해 실행중인 컨테이너에 접속하여 디버깅이 가능하다. 21년 3월 부터 해당 기능이 AWS의 ECS에서도 사용가능하게 되었는데, 해당 기능을 사용하며 만났던 문제들을 기록.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Create Immutable Server using AWS Image Builder &amp;amp; Auto Scaling Group</title>
      <link href="https://heuristicwave.github.io/ImageBuilder" rel="alternate" type="text/html" title="Create Immutable Server using AWS Image Builder &amp; Auto Scaling Group" />
      <published>2022-02-21T00:00:00+00:00</published>
      <updated>2022-02-21T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/ImageBuilder</id>
      <content type="html" xml:base="https://heuristicwave.github.io/ImageBuilder">&lt;p&gt;본 글은 2021년 4월 30일 &lt;a href=&quot;https://aws.amazon.com/about-aws/whats-new/2021/04/ec2-image-builder-supports-auto-scaling-launch-template/&quot;&gt;EC2 Image Builder supports Auto Scaling launch template&lt;/a&gt;에
소개된 기능을 활용해 Image Builder로 Golden AMI를 만들고,
해당 이미지로 Auto Scaling Group의 launch template을 업데이트하는 방법을 소개합니다.&lt;/p&gt;

&lt;h1 id=&quot;intro&quot;&gt;Intro&lt;/h1&gt;

&lt;p&gt;클라우드를 다루다 보면 &lt;strong&gt;Netflix&lt;/strong&gt; 가 여러 분야에서 앞장서 있는 것을 확인할 수 있습니다.
그중에서 Immutable Server Pattern을 알리는데 기여한 2013년에 발간된 &lt;a href=&quot;https://netflixtechblog.com/ami-creation-with-aminator-98d627ca37b0&quot;&gt;AMI Creation with Aminator&lt;/a&gt;를
꼭 한번 읽어보시기 바랍니다. 과거 넷플릭스는 AWS의 이미지 파일을 생성하기 위해 Aminator라는 도구를 사용했지만,
본 포스팅에서는 이미지 빌더로 AMI를 만들고 Auto Scaling Group에 적용시키는 방법을 배워 Immutable Server Pattern을 학습해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;immutable-server&quot;&gt;Immutable Server&lt;/h2&gt;

&lt;p&gt;Immutable Server 대한 내용은 martin fowler 블로그에 소개된 &lt;a href=&quot;https://martinfowler.com/bliki/ImmutableServer.html&quot;&gt;ImmutableServer&lt;/a&gt;
글을 보시면 굉장히 잘 설명되어 있습니다. 요약 + 그동안의 제 뇌피셜을 함께 말씀드리면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;서버를 운영하다 보면 업데이트를 비롯한 다양한 이슈들로 인해 구성요소가 자주 변하게 됩니다.
그렇게 운영하다 보면 무언가 꼬여 서버를 재 생성하는 일이 발생하는데 아래와 같은 라이프 사이클을 만나게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://martinfowler.com/bliki/images/immutableServer/PhoenixServerLifecycle.png&quot; alt=&quot;phoenixServerLifecycle&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 상황에서 구성이 다른 여러 대의 서버를 가지게 되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Configuration drift&lt;/code&gt;가 발생했다고 표현합니다.
또한 위 그림처럼 자꾸 새로운 이미지로 회귀하니까, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Shift Left&lt;/code&gt;라고도 표현하고 이를 한국어로 표현하는 말을 찾아보니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;원점 회귀&lt;/code&gt;라는 표현도 쓰입니다.&lt;/p&gt;

&lt;p&gt;구성 변경이 잦은 서버는 깨지기(fragile) 쉽고, 또 장애가 발생할 경우 재현이 어려울뿐더러 변경 시 연쇄적인 장애를 유발할 가능성이 있습니다.
이를 두고 깨지기 쉬운 눈송이 같다 하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Snowflake Server&lt;/code&gt;라 부릅니다.
이 상황을 피하기 위해, Configuration drift를 피하는 Base Image(Configuration이 발생하면 새롭게 생성)를 활용한 방법을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Phoenix Server&lt;/code&gt;
라 부릅니다. &lt;em&gt;(&lt;a href=&quot;https://martinfowler.com/bliki/PhoenixServer.html&quot;&gt;Phoenix Server&lt;/a&gt; 용어는 마틴 파울러의 동료 &lt;a href=&quot;https://twitter.com/kornys&quot;&gt;Kornelis Sietsma&lt;/a&gt;가 제안했다 합니다.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/immutableServer.png&quot; alt=&quot;immutableServer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;피닉스 서버의 개념은 기본 이미지(Base AMI, Golden AMI)를 통해 언제나 일관성 있는 환경을 제공했고,
이러한 개념들이 자연스럽게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Immutable Server&lt;/code&gt;의 개념으로 이어졌습니다.
&lt;em&gt;(최근에는 Immutable Server를 넘어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Immutable Infrastructure&lt;/code&gt;의 개념도 있습니다!)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;이미지-빌더와-오토-스케일-그룹으로-이뮤터블-서버-구축하기&quot;&gt;이미지 빌더와 오토 스케일 그룹으로 이뮤터블 서버 구축하기&lt;/h2&gt;

&lt;p&gt;클라우드에서의 Immutable Server Pattern 검색하면 아래와 같은 좋은 예시들이 나옵니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/blogs/mt/create-immutable-servers-using-ec2-image-builder-aws-codepipeline/&quot;&gt;Create immutable servers using EC2 Image Builder and AWS CodePipeline&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloudblogs.microsoft.com/opensource/2018/05/23/immutable-infrastructure-azure-vsts-terraform-packer-ansible/&quot;&gt;Tutorial: Immutable infrastructure for Azure, using VSTS, Terraform, Packer and Ansible&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://learn.hashicorp.com/tutorials/terraform/packer&quot;&gt;Provision Infrastructure with Packer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://heuristicwave.github.io/Packer&quot;&gt;하시코프 튜토리얼을 보고 만든 필자의 블로그 🥲&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러나 이제부터 다룰, 이미지 빌더와 오토 스케일 그룹으로 이뮤터블 서버 패턴을 만족시킬 수 있습니다.
AWS에서 제공하는 AutoScale은 탄력적인 확장과 축소를 제공하지만 Desired Capacity 기능을 활용해 항상 동일한 서버의 수를 유지할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/background/imagebuilder.png&quot; alt=&quot;imageBuilder&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Image Builder의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Image pipelines&lt;/code&gt;를 활용해 원본 AMI로부터 원하는 형태의 Output(Custom/Golden/Base AMI)을 제작합니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Distribution settings&lt;/code&gt;을 통해 lt(Launch Template)에 1번에서 생성한 AMI로 교체하여 새로운 버전을 만듭니다.&lt;/li&gt;
  &lt;li&gt;이제, 새롭게 생성되는 ASG(Auto Scaling Group)은 새롭게 버전 업된 lt를 통해 인스턴스를 생성합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;3번의 ASG의 경우, Refresh를 하기 전까지는 이전 상태의 lt를 기준으로 인스턴스가 운영되고 있습니다.
이미지 생성과 동시에 새로운 AMI로 EC2 Refresh를 할 수 있는 방법이 있지만,
새롭게 생성된 인스턴스가 운영환경에 바로 적용되는 것은 바람직하지 않으므로 해당 부분에 대한 자동화는 제외하였습니다.
만약 검증된 AMI를 생성한다면, Lambda 혹은 기타 방법 등을 통해 Refresh 하여 이미지 생성부터 배포까지 자동화할 수 있습니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;추후 다른 포스팅에서 자세히 다룰 예정이지만, 이러한 패턴은 Immutable Infrastructure의 한 요소를 이루기도 합니다.&lt;/p&gt;

&lt;h2 id=&quot;-workshop&quot;&gt;📜 Workshop&lt;/h2&gt;

&lt;h3 id=&quot;0️⃣-launch-template--auto-scaling-groups-생성&quot;&gt;0️⃣ Launch Template &amp;amp; Auto Scaling groups 생성&lt;/h3&gt;

&lt;p&gt;기존 환경에 0️⃣이 준비되어 있다면 다음 단계인 &lt;strong&gt;Distribution settings&lt;/strong&gt;으로 넘어가도 좋습니다.&lt;/p&gt;

&lt;p&gt;해당 단계는 제가 굉장히 게으른 관계로 AWS Documentation : &lt;a href=&quot;https://docs.aws.amazon.com/autoscaling/ec2/userguide/create-asg-launch-template.html&quot;&gt;Creating an Auto Scaling group using a launch template&lt;/a&gt;로 대체하겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;💡 만약 기존 환경이 Launch Template이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Launch Configurations&lt;/code&gt;으로 구성되어 있을 경우,
콘솔 화면에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Copy to launch template&lt;/code&gt; 버튼을 누르시면 손쉽게 lt로 변경 가능합니다. &lt;br /&gt;
💡 Launch Template과 Launch Configurations는 굉장히 유사하지만, Launch Template의 경우 더 다양한 기능들을 제공합니다.
특히 버전관리 기능을 통해 Rollback을 하거나, 업데이트시 ASG를 활용한 Rolling Update가 가능해 Launch Template 사용을 권장합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1️⃣-distribution-settings&quot;&gt;1️⃣ Distribution settings&lt;/h3&gt;

&lt;p&gt;EC2 Image Builder 콘솔 화면에 접속해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Distribution settings&lt;/code&gt;에서 새로운 세팅을 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/distribution.png&quot; alt=&quot;distribution&quot; /&gt;&lt;/p&gt;

&lt;p&gt;필수 항목인 이름을 작성하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Region settings&lt;/code&gt;에서 배포할 리전을 확인한 후,
하단의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Launch template configuration&lt;/code&gt;에서 Step 0️⃣에서 작성한 lt를 지정하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create settings&lt;/code&gt;로 생성합니다.&lt;/p&gt;

&lt;h3 id=&quot;2️⃣-image-pipelines&quot;&gt;2️⃣ Image pipelines&lt;/h3&gt;

&lt;h4 id=&quot;step-1&quot;&gt;Step 1&lt;/h4&gt;

&lt;p&gt;Distribution settings 작성이 완료되었다면, 콘솔에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Image pipelines&lt;/code&gt;에 접속하여 아래 정보들을 기재합니다.
아래 사진의 좌측 Step 5까지의 과정을 거치면 목표로 했던 환경이 완성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/imagepipeline.png&quot; alt=&quot;pipeline&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Build schedule&lt;/code&gt;에서는 주기적으로 파이프라인을 실행할 수 있는 방법들을 제공하는데 운영자가 원하는 방식으로 설정할 수 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;step-2&quot;&gt;Step 2&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Choose recipe&lt;/code&gt; 단계에서는 기존에 만들어둔 &lt;strong&gt;recipe&lt;/strong&gt;가 없으므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create new recipe&lt;/code&gt;를 선택하고, &lt;strong&gt;Image type&lt;/strong&gt;으로 &lt;strong&gt;AMI&lt;/strong&gt;를 선택합니다.&lt;/p&gt;

&lt;p&gt;다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Base image&lt;/code&gt;를 고르는 단계에서는 아래 화면과 같이 &lt;strong&gt;관리형 이미지&lt;/strong&gt;를 사용하거나 기존에 작성한 &lt;strong&gt;Custom AMI ID&lt;/strong&gt;를 사용해도 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/baseimage.png&quot; alt=&quot;baseimage&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그다음 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Instance configuration&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Working directory&lt;/code&gt;에서는 &lt;strong&gt;기본 값&lt;/strong&gt;으로 둬도 상관없지만
&lt;strong&gt;SSM, User data, Working directory path&lt;/strong&gt;의 필요 여부에 따라 활용하시면 됩니다.&lt;/p&gt;

&lt;p&gt;이어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Components&lt;/code&gt;에서는 Golden AMI를 구축하기 위해 선행되어야 하는 각종 Agent나 소프트웨어(Apache, dotnet etc)를 선택할 수 있습니다.
저는 편의상 CloudWatch Agent를 선택했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/components.png&quot; alt=&quot;components&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그다음 이어지는 &lt;strong&gt;Test components, Storage, Tags&lt;/strong&gt; 역시 필요 여부에 따라 활용하시면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;step-3&quot;&gt;Step 3&lt;/h4&gt;

&lt;p&gt;3단계에 진입하면 아래 사진과 같이 이미지 빌더의 인프라 Config 값들을 정의할 수 있는 공간이 나옵니다.
3번째 버튼인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create New infrastructure configuration&lt;/code&gt;으로 직접 인스턴스 유형, 네트워크, SNS topic을 설정이 가능하지만,
저는 1번 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Create infrastructure configuration using service defaults&lt;/code&gt;로 기본 구성 값들을 잡아주었습니다.
(IAM Role과 SNS Topic도 자동으로 생성해 주고 굉장히 편리하네요.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/defineconfig.png&quot; alt=&quot;config&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;step-4&quot;&gt;Step 4&lt;/h4&gt;

&lt;p&gt;드디어, 이전 &lt;strong&gt;1️⃣ Distribution settings&lt;/strong&gt; 과정에서 만들어둔 &lt;strong&gt;배포 설정&lt;/strong&gt; 해당 단계에서 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/associatelt.png&quot; alt=&quot;asso&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;step-5&quot;&gt;Step 5&lt;/h4&gt;

&lt;p&gt;Review 단계까지 구성 요소들을 검토해 보고 Create pipeline을 누르고 Image pipelines 콘솔로 돌아오면 아래와 같은 화면을 만나게 됩니다.
아래 캡처화면의 경우 이미 빌드가 끝난 상태이지만, 테스트를 위해서 &lt;strong&gt;Actions - Run pipeline&lt;/strong&gt; 단계를 거치면,
ec2 콘솔에서 image build를 위한 builder 인스턴스가 생성되고 종료되는 것을 과정을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/imagebuilder/imgconsole.png&quot; alt=&quot;console&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3️⃣-review&quot;&gt;3️⃣ Review&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;EC2 - Images - AMIs&lt;/strong&gt;에서 새롭게 생성된 AMI 확인&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;EC2 - Launch templates&lt;/strong&gt;에서 새롭게 버전이 올라간 lt 확인, 여기서 Versions 정보를 누르면 Image Builder가 생성한 Description을 확인할 수 있습니다.
&lt;img src=&quot;../../assets/built/images/post/imagebuilder/version.png&quot; alt=&quot;version&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;제대로 작동하는지 확인하기 위해 기존의 EC2 하나를 종료시키면, 저의 경우 ASG의 Desired가 2로 설정했으므로 하나의 인스턴스가 새로운 버전으로 변경됩니다.
이는 &lt;strong&gt;EC2 - Auto Scaling groups&lt;/strong&gt;에서 확인할 수 있습니다.
&lt;img src=&quot;../../assets/built/images/post/imagebuilder/asg.png&quot; alt=&quot;asg&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4️⃣-clean-up&quot;&gt;4️⃣ Clean Up&lt;/h3&gt;

&lt;p&gt;분해는 조립의 역순으로?! 2️⃣ -&amp;gt; 1️⃣ -&amp;gt; 0️⃣ 역순으로 리소스를 정리하고 3️⃣ Review 항목을 점검하여 모든 리소스가 회수되었는지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;지금까지 각종 이야기 거리들과 EC2 Image Builder를 사용하며 Immutable Server Pattern을 학습해 보았습니다.
과거 제가 Packer로 관련 환경을 구축한 적이 있는데, 역시 AWS 환경에서는 AWS의 서비스를 사용하는 게 연계도 용이하고 구축도 쉽네요.&lt;/p&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해 주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;📚 References&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;글 중간중간 하이퍼 링크로 Reference 들을 달아두었습니다.
특히, 이번 포스팅 레퍼런스들은 좋은 내용들이 많으니 원본들을 읽어보시고 당시 제가 느낀 기쁨들을 함께 느낄수 있으면 좋겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      
        <category term="devops" />
      

      
        <summary type="html">본 글은 2021년 4월 30일 EC2 Image Builder supports Auto Scaling launch template에 소개된 기능을 활용해 Image Builder로 Golden AMI를 만들고, 해당 이미지로 Auto Scaling Group의 launch template을 업데이트하는 방법을 소개합니다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">AWS CDK Library, Construct Hub</title>
      <link href="https://heuristicwave.github.io/ConstructHub" rel="alternate" type="text/html" title="AWS CDK Library, Construct Hub" />
      <published>2021-12-21T00:00:00+00:00</published>
      <updated>2021-12-21T00:00:00+00:00</updated>
      <id>https://heuristicwave.github.io/ConstructHub</id>
      <content type="html" xml:base="https://heuristicwave.github.io/ConstructHub">&lt;p&gt;본 글은 지난 AWS re:Invent 2021에서 발표된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Construct Hub&lt;/code&gt;를 둘러보며 느낀 첫인상에 대한 글입니다.&lt;/p&gt;

&lt;h1 id=&quot;intro&quot;&gt;Intro&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/8_Xs8Ik0h1w?t=4666&quot;&gt;AWS re:Invent 2021, 아마존 CTO인 Dr. Werner Vogels 키노트&lt;/a&gt;에서
AWS CDK 라이브러리들을 활용할 수 있는 &lt;a href=&quot;https://constructs.dev/&quot;&gt;Construct Hub&lt;/a&gt;가 발표되었습니다.
보통 AWS 리인벤트에서는 AWS 고유의 서비스들이 소개되는데요,
이번에 말씀드릴 Construct Hub는 AWS의 솔루션이 아닌 오픈 소스 커뮤니티이자,
&lt;strong&gt;CDK 라이브러리를 검색하고 공유할 수 있는 장&lt;/strong&gt;이라고 할 수 있습니다.
Construct Hub를 통해 AWS가 그리는 IaC(Infrastructure as Code)의 미래를 함께 만나보겠습니다.&lt;/p&gt;

&lt;p&gt;우선, Construct Hub를 소개하기 앞서 AWS의 IaC 도구들에 대하여 간략하게 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;️-aws-cloudformation&quot;&gt;️📂 AWS CloudFormation&lt;/h2&gt;

&lt;p&gt;2011년 AWS의 리소스를 JSON 또는 YAML 형식으로 인프라를 템플릿화 할 수 있는 CloudFormation을 발표했습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;예) AWS S3 버킷 리소스를 제어하는 CloudFormation 코드&lt;/p&gt;
  &lt;pre&gt;&lt;code class=&quot;language-YAML&quot;&gt;Resources:
  HelloBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: PublicRead
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: error.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;그러나, 인프라가 복잡해질수록 CloudFormation 코드의 길이도 길어지고 리소스 간의 관계도 파악하기 어려워 관리의 피로도가 증가하게 되었습니다.
AWS는 이러한 CloudFormation의 약점을 보완하고 개발자들이 YAML 형식으로 인프라를 정의하는 게 아니라,
&lt;strong&gt;선호하는 프로그래밍 언어로 클라우드 인프라를 정의할 수 있도록 Cloud Development Kit(CDK)&lt;/strong&gt; 를 2019년에 정식으로 출시했습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;️-aws-cloud-development-kit&quot;&gt;⌨️ AWS Cloud Development Kit&lt;/h2&gt;

&lt;p&gt;CDK는 익숙한 프로그래밍 언어를 사용해 클라우드 애플리케이션 리소스를 정의할 수 있는 오픈 소스 소프트웨어 개발 프레임워크입니다.
CDK는 어떤 방식으로, 앞서 언급된 CloudFormation의 약점들을 보완하는지 그림과 함께 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/construct/cdk.png&quot; alt=&quot;cdk&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CDK는 &lt;strong&gt;Construct&lt;/strong&gt;의 집합체라 말할 수 있습니다.
&lt;strong&gt;Construct&lt;/strong&gt;는 클라우드 서비스를 이루는 컴포넌트라 생각하셔도 좋습니다.&lt;/p&gt;

&lt;p&gt;CDK 프레임워크를 통해 개발자 혹은 클라우드 운영자는 타입스크립트, 파이썬, 닷넷, 자바 등의 익숙한 프로그래밍 언어 중
하나를 선택하여, construct 라이브러리를 사용해 프로그래밍 합니다.
하나의 Stack으로 엮어진 소스코드를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cdk synth&lt;/code&gt; 라는 명령어로 CloudFormation에서 사용되는 템플릿으로 변환하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cdk deploy&lt;/code&gt; 명령어로 인프라를 배포합니다.&lt;/p&gt;

&lt;p&gt;CDK로 작성된 인프라 코드는 프로그래밍 언어의 이점을 그대로 채택하여,
해당 언어에 익숙한 사람이라면 YAML로 작성된 CloudFormation 보다 인프라의 환경을 파악하기 쉽습니다.
실제로 올해 키노트에 언급된 &lt;a href=&quot;https://youtu.be/8_Xs8Ik0h1w?t=4872&quot;&gt;Liberty Mutual INSURANCE사의 CDK 도입 사례&lt;/a&gt;에서
1500라인의 CloudFormation 코드를 CDK에서 단 14줄로 구현하며 CDK의 뛰어난 가시성을 알렸습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/construct/cdk2.png&quot; alt=&quot;cdk_migration&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-construct-hub&quot;&gt;🗂 Construct Hub&lt;/h2&gt;

&lt;p&gt;대망의 Construct Hub를 소개하기 위해 먼 길을 돌아왔습니다.😓
맨 처음에 Construct Hub를 오픈 소스 커뮤니티이자, CDK 라이브러리를 검색하고 공유할 수 있는 장이라고 소개한 말이 맞는지 그림과 함께 확인해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/construct/hub1.png&quot; alt=&quot;construct_hub&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://constructs.dev/&quot;&gt;Construct Hub&lt;/a&gt;의 메인 홈페이지를 확인해 보면 CDK 라이브러리를 검색할 수 있는
‘서치 바’와 현재 ‘지원하는 언어’와 ‘서비스 프로바이더’(AWS, Datadog, Mongo DB, Aqua Security 등)가 보입니다.&lt;/p&gt;

&lt;p&gt;이 중에서도 화면 왼쪽에 위치한 다양한 CDK들의 종류에 대해 궁금증이 생기실 것 같습니다.&lt;/p&gt;

&lt;p&gt;앞서 소개한 AWS CDK는 프로그래밍 언어로 작성한 인프라 코드를 Cloudformation으로 템플릿을 생성했습니다.
이처럼 CDK가 생성하는 템플릿이 AWS Cloudformation으로 활용 가능하도록 하는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AWS CDK&lt;/code&gt;,
쿠버네티스로 활용 가능하도록 하는 것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CDK8s&lt;/code&gt;, 테라폼으로 활용 가능하도록 하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CDKtf&lt;/code&gt;라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/construct/cdk3.png&quot; alt=&quot;cdk_type&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 현재 3가지 Type을 지원하고 있으며, 향후 다른 도구들도 지원할 가능성이 있다고 합니다.&lt;/p&gt;

&lt;p&gt;다음으로는 Construct Hub에 등록된 다양한 Construct 검색 결과입니다. 
현재는 대부분 Construct는 Hahicorp, Datadog과 같은 클라우드 서비스 Publisher 들이 참여했지만,
개인도 &lt;a href=&quot;https://aws.github.io/jsii/&quot;&gt;JSII&lt;/a&gt; (CDK가 다중 언어 라이브러리를 제공할 수 있도록 하는 기술)
기반의 construct를 만들고 aws-cdk, cdk8s, cdktf 등의 키워드와 함께 npm 레지스트리에 공개되어 있다면 약 30분 내에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Construct Hub&lt;/code&gt;에도 개시된다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../../assets/built/images/post/construct/hub2.png&quot; alt=&quot;construct_hub2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;화면에 보이는 특이점으로는 HashiCorp가 제공하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CDKtf&lt;/code&gt;를 통해,
다른 클라우드 서비스들과 통합하여 AWS 서비스 만이 아닌 &lt;strong&gt;모든 클라우드를 CDK로 제어 가능&lt;/strong&gt;하게 하려는 큰 그림을 그려나가고 있다는 것을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;outro&quot;&gt;Outro&lt;/h2&gt;

&lt;p&gt;지금까지 Construct Hub를 간단하게 살펴보며, AWS IaC 도구들의 변천사와 AWS가 그리는 IaC의 미래를 엿볼 수 있었습니다.&lt;/p&gt;

&lt;p&gt;그중에서도 흥미로웠던 요소들은 다음 2가지로 말씀드릴 수 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;IaC를 도입한 조직의 경우, Terraform, Ansible 등 여러 IaC 도구를 각각의 IaC 도구들의 특성에 맞게 복합적으로 운영합니다. CDK가 다방면으로 IaC 도구를 지원(AWS CDK, CDK8s, CDKtf) 하게 만들어 관리 복잡도를 줄이려는 노력이 흥미롭습니다.&lt;/li&gt;
  &lt;li&gt;CDKtf를 통해, 타 클라우드 서비스를 CDK로 제어하게 된다는 점이 흥미롭습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;사실 CDK8s, CDKtf 모두 Construct Hub가 나오기 이전부터 존재했지만, Construct Hub에 개시된 문서들을 보니 더 흥미롭게 다가옵니다.&lt;/p&gt;

&lt;p&gt;아직 세상에 알려진지 얼마 되지 않은 Construct Hub를 활용하기에는 어려움이 있지만, 누구나 Construct Hub에 기여할 수 있는 오픈소스 생태계를 구축한 만큼 빠른 성장이 기대됩니다. Construct Hub가 기여할 IaC 미래에 긍정적인 기대를 걸어봅니다.&lt;/p&gt;

&lt;p&gt;소중한 시간을 내어 읽어주셔서 감사합니다! 잘못된 내용은 지적해주세요! 😃&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-references&quot;&gt;📚 References&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/about-aws/whats-new/2021/12/aws-construct-hub-availability/&quot;&gt;AWS Construct Hub availability&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://constructs.dev/&quot;&gt;Construct Hub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Heuristic Wave</name>
        
        
      </author>

      

      
        <category term="aws" />
      

      
        <summary type="html">본 글은 지난 AWS re:Invent 2021에서 발표된 Construct Hub를 둘러보며 느낀 첫인상에 대한 글입니다.</summary>
      

      
      
    </entry>
  
</feed>
